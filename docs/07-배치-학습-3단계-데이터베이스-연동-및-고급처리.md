# 07. 배치 학습 3단계: 데이터베이스 연동 및 고급 처리

## 🎯 학습 목표
- 데이터베이스에서 데이터를 읽어오는 ItemReader 구현
- 복잡한 비즈니스 로직이 포함된 ItemProcessor 작성
- 여러 데이터베이스에 동시에 저장하는 CompositeWriter 구현
- 조건부 Step 실행 및 Flow 제어 학습

## 📊 시나리오: 주문 데이터 처리 시스템

### 비즈니스 요구사항
1. **주문 상태 업데이트**: 미처리 주문을 배송 준비 상태로 변경
2. **재고 차감**: 주문 상품의 재고 수량 감소
3. **포인트 적립**: 고객별 구매 금액에 따른 포인트 적립
4. **알림 발송**: 처리 완료된 주문에 대한 알림 (로그만 기록)
5. **통계 업데이트**: 일일 매출 통계 테이블 업데이트

## 🗄️ 데이터베이스 스키마 설계

### 1. 엔티티 클래스들

#### Order 엔티티
```java
package com.example.batchtutorial.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "orders")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "customer_id", nullable = false)
    private Long customerId;
    
    @Column(name = "order_number", nullable = false, unique = true, length = 50)
    private String orderNumber;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private OrderStatus status;
    
    @Column(name = "total_amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal totalAmount;
    
    @Column(name = "order_date", nullable = false)
    private LocalDateTime orderDate;
    
    @Column(name = "processed_date")
    private LocalDateTime processedDate;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // 주문 아이템들과의 관계
    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<OrderItem> orderItems;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}

// 주문 상태 열거형
enum OrderStatus {
    PENDING,        // 미처리
    PROCESSING,     // 처리중
    SHIPPED,        // 배송완료
    DELIVERED,      // 배달완료
    CANCELLED       // 취소
}
```

#### OrderItem 엔티티
```java
package com.example.batchtutorial.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Entity
@Table(name = "order_items")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderItem {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;
    
    @Column(name = "product_id", nullable = false)
    private Long productId;
    
    @Column(name = "product_name", nullable = false, length = 100)
    private String productName;
    
    @Column(name = "quantity", nullable = false)
    private Integer quantity;
    
    @Column(name = "unit_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal unitPrice;
    
    @Column(name = "total_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal totalPrice;
}
```

#### Product 엔티티 (재고 관리)
```java
package com.example.batchtutorial.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "products")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;
    
    @Column(name = "price", nullable = false, precision = 10, scale = 2)
    private BigDecimal price;
    
    @Column(name = "stock_quantity", nullable = false)
    private Integer stockQuantity;
    
    @Column(name = "category", length = 50)
    private String category;
    
    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate  
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
    
    // 재고 차감 메서드
    public boolean decreaseStock(int quantity) {
        if (this.stockQuantity >= quantity) {
            this.stockQuantity -= quantity;
            return true;
        }
        return false;
    }
}
```

#### Customer 엔티티 (포인트 적립)
```java
package com.example.batchtutorial.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "customers")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Customer {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;
    
    @Column(name = "email", nullable = false, unique = true, length = 100)
    private String email;
    
    @Column(name = "phone", length = 20)
    private String phone;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "grade", nullable = false)
    private CustomerGrade grade = CustomerGrade.BRONZE;
    
    @Column(name = "total_points", nullable = false, precision = 10, scale = 2)
    private BigDecimal totalPoints = BigDecimal.ZERO;
    
    @Column(name = "total_purchase_amount", nullable = false, precision = 15, scale = 2)
    private BigDecimal totalPurchaseAmount = BigDecimal.ZERO;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
    
    // 포인트 적립
    public void addPoints(BigDecimal points) {
        this.totalPoints = this.totalPoints.add(points);
    }
    
    // 구매 금액 누적
    public void addPurchaseAmount(BigDecimal amount) {
        this.totalPurchaseAmount = this.totalPurchaseAmount.add(amount);
        updateGrade();
    }
    
    // 고객 등급 업데이트
    private void updateGrade() {
        BigDecimal amount = this.totalPurchaseAmount;
        if (amount.compareTo(new BigDecimal("1000000")) >= 0) {
            this.grade = CustomerGrade.DIAMOND;
        } else if (amount.compareTo(new BigDecimal("500000")) >= 0) {
            this.grade = CustomerGrade.GOLD;
        } else if (amount.compareTo(new BigDecimal("100000")) >= 0) {
            this.grade = CustomerGrade.SILVER;
        } else {
            this.grade = CustomerGrade.BRONZE;
        }
    }
}

// 고객 등급
enum CustomerGrade {
    BRONZE(0.01),   // 1%
    SILVER(0.02),   // 2%
    GOLD(0.03),     // 3%
    DIAMOND(0.05);  // 5%
    
    private final double pointsRate;
    
    CustomerGrade(double pointsRate) {
        this.pointsRate = pointsRate;
    }
    
    public double getPointsRate() {
        return pointsRate;
    }
}
```

#### DailySales 엔티티 (통계)
```java
package com.example.batchtutorial.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "daily_sales")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class DailySales {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "sales_date", nullable = false, unique = true)
    private LocalDate salesDate;
    
    @Column(name = "total_orders", nullable = false)
    private Long totalOrders = 0L;
    
    @Column(name = "total_amount", nullable = false, precision = 15, scale = 2)
    private BigDecimal totalAmount = BigDecimal.ZERO;
    
    @Column(name = "average_order_amount", precision = 10, scale = 2)
    private BigDecimal averageOrderAmount = BigDecimal.ZERO;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
    
    // 주문 추가
    public void addOrder(BigDecimal orderAmount) {
        this.totalOrders++;
        this.totalAmount = this.totalAmount.add(orderAmount);
        updateAverageAmount();
    }
    
    // 평균 주문 금액 계산
    private void updateAverageAmount() {
        if (totalOrders > 0) {
            this.averageOrderAmount = totalAmount.divide(
                BigDecimal.valueOf(totalOrders), 2, BigDecimal.ROUND_HALF_UP
            );
        }
    }
}
```

### 2. Repository 인터페이스들

```java
package com.example.batchtutorial.repository;

import com.example.batchtutorial.entity.Order;
import com.example.batchtutorial.entity.OrderStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    // 특정 상태의 주문들 조회
    List<Order> findByStatusOrderByOrderDateAsc(OrderStatus status);
    
    // 처리되지 않은 주문들 조회 (Batch Reader용)
    @Query("SELECT o FROM Order o WHERE o.status = :status ORDER BY o.orderDate ASC")
    List<Order> findUnprocessedOrders(@Param("status") OrderStatus status);
    
    // 특정 기간의 주문 조회
    List<Order> findByOrderDateBetween(LocalDateTime startDate, LocalDateTime endDate);
    
    // 고객별 주문 조회
    List<Order> findByCustomerIdOrderByOrderDateDesc(Long customerId);
}

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // 활성화된 상품들 조회
    List<Product> findByIsActiveTrueOrderByNameAsc();
    
    // 재고 부족 상품 조회
    List<Product> findByStockQuantityLessThanAndIsActiveTrue(Integer threshold);
    
    // 카테고리별 상품 조회
    List<Product> findByCategoryAndIsActiveTrueOrderByNameAsc(String category);
}

@Repository
public interface CustomerRepository extends JpaRepository<Customer, Long> {
    
    // 이메일로 고객 조회
    Optional<Customer> findByEmail(String email);
    
    // 등급별 고객 조회
    List<Customer> findByGradeOrderByTotalPurchaseAmountDesc(CustomerGrade grade);
}

@Repository
public interface DailySalesRepository extends JpaRepository<DailySales, Long> {
    
    // 특정 날짜의 매출 조회
    Optional<DailySales> findBySalesDate(LocalDate salesDate);
    
    // 기간별 매출 조회
    List<DailySales> findBySalesDateBetweenOrderBySalesDateAsc(LocalDate startDate, LocalDate endDate);
}
```

## 🔧 고급 배치 컴포넌트 구현

### 1. 데이터베이스 ItemReader
```java
package com.example.batchtutorial.batch.reader;

import com.example.batchtutorial.entity.Order;
import com.example.batchtutorial.entity.OrderStatus;
import org.springframework.batch.item.database.JpaPagingItemReader;
import org.springframework.batch.item.database.builder.JpaPagingItemReaderBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import jakarta.persistence.EntityManagerFactory;
import java.util.Map;

/**
 * 데이터베이스에서 주문 데이터를 읽는 ItemReader
 */
@Configuration
public class OrderItemReaderConfig {
    
    @Autowired
    private EntityManagerFactory entityManagerFactory;
    
    /**
     * 미처리 주문을 페이징으로 읽어오는 Reader
     */
    @Bean
    public JpaPagingItemReader<Order> pendingOrderReader() {
        return new JpaPagingItemReaderBuilder<Order>()
                .name("pendingOrderReader")
                .entityManagerFactory(entityManagerFactory)
                .queryString("SELECT o FROM Order o WHERE o.status = :status ORDER BY o.orderDate ASC")
                .parameterValues(Map.of("status", OrderStatus.PENDING))
                .pageSize(10)  // 페이지 크기 10
                .build();
    }
    
    /**
     * 처리중인 주문을 읽어오는 Reader
     */
    @Bean
    public JpaPagingItemReader<Order> processingOrderReader() {
        return new JpaPagingItemReaderBuilder<Order>()
                .name("processingOrderReader")  
                .entityManagerFactory(entityManagerFactory)
                .queryString("SELECT o FROM Order o WHERE o.status = :status ORDER BY o.orderDate ASC")
                .parameterValues(Map.of("status", OrderStatus.PROCESSING))
                .pageSize(5)
                .build();
    }
}
```

### 2. 복합 ItemProcessor
```java
package com.example.batchtutorial.batch.processor;

import com.example.batchtutorial.entity.*;
import com.example.batchtutorial.repository.CustomerRepository;
import com.example.batchtutorial.repository.ProductRepository;
import com.example.batchtutorial.dto.ProcessedOrderDto;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Optional;

/**
 * 주문 처리를 위한 복합 ItemProcessor
 */
@Slf4j
@Configuration
public class OrderProcessorConfig {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private CustomerRepository customerRepository;
    
    /**
     * 주문을 처리하는 메인 Processor
     */
    @Bean
    public ItemProcessor<Order, ProcessedOrderDto> orderProcessor() {
        return new ItemProcessor<Order, ProcessedOrderDto>() {
            @Override
            public ProcessedOrderDto process(Order order) throws Exception {
                
                log.info("Processing order: {} (Customer: {})", 
                        order.getOrderNumber(), order.getCustomerId());
                
                try {
                    // 1. 고객 정보 조회 및 검증
                    Optional<Customer> customerOpt = customerRepository.findById(order.getCustomerId());
                    if (customerOpt.isEmpty()) {
                        log.warn("Customer not found for order {}: {}", 
                                order.getOrderNumber(), order.getCustomerId());
                        return null;  // 고객이 없으면 처리 중단
                    }
                    Customer customer = customerOpt.get();
                    
                    // 2. 재고 확인 및 차감
                    if (!processInventory(order)) {
                        log.warn("Insufficient stock for order: {}", order.getOrderNumber());
                        return null;  // 재고 부족 시 처리 중단
                    }
                    
                    // 3. 주문 상태 업데이트
                    order.setStatus(OrderStatus.PROCESSING);
                    order.setProcessedDate(LocalDateTime.now());
                    
                    // 4. 고객 정보 업데이트 (구매 금액, 포인트)
                    updateCustomer(customer, order);
                    
                    // 5. 처리 결과 DTO 생성
                    ProcessedOrderDto result = new ProcessedOrderDto();
                    result.setOrder(order);
                    result.setCustomer(customer);
                    result.setProcessedAt(LocalDateTime.now());
                    result.setPointsEarned(calculatePoints(customer, order.getTotalAmount()));
                    
                    log.info("Successfully processed order: {} (Points earned: {})", 
                            order.getOrderNumber(), result.getPointsEarned());
                    
                    return result;
                    
                } catch (Exception e) {
                    log.error("Error processing order {}: {}", order.getOrderNumber(), e.getMessage(), e);
                    throw e;  // 예외 발생 시 재발생
                }
            }
        };
    }
    
    /**
     * 재고 처리 (차감)
     */
    private boolean processInventory(Order order) {
        for (OrderItem item : order.getOrderItems()) {
            Optional<Product> productOpt = productRepository.findById(item.getProductId());
            
            if (productOpt.isEmpty()) {
                log.warn("Product not found: {}", item.getProductId());
                return false;
            }
            
            Product product = productOpt.get();
            
            if (!product.getIsActive()) {
                log.warn("Product is inactive: {}", product.getName());
                return false;
            }
            
            if (!product.decreaseStock(item.getQuantity())) {
                log.warn("Insufficient stock for product {}: required {}, available {}", 
                        product.getName(), item.getQuantity(), product.getStockQuantity());
                return false;
            }
            
            // 재고 변경 사항 저장
            productRepository.save(product);
            
            log.debug("Stock decreased for product {}: -{} (remaining: {})", 
                    product.getName(), item.getQuantity(), product.getStockQuantity());
        }
        
        return true;
    }
    
    /**
     * 고객 정보 업데이트
     */
    private void updateCustomer(Customer customer, Order order) {
        // 구매 금액 누적 (등급 자동 업데이트 포함)
        customer.addPurchaseAmount(order.getTotalAmount());
        
        // 포인트 적립
        BigDecimal points = calculatePoints(customer, order.getTotalAmount());
        customer.addPoints(points);
        
        log.debug("Customer updated: {} (New grade: {}, Points added: {})", 
                customer.getName(), customer.getGrade(), points);
    }
    
    /**
     * 포인트 계산 (고객 등급에 따라)
     */
    private BigDecimal calculatePoints(Customer customer, BigDecimal orderAmount) {
        double pointsRate = customer.getGrade().getPointsRate();
        return orderAmount.multiply(BigDecimal.valueOf(pointsRate));
    }
}
```

### 3. 처리 결과 DTO
```java
package com.example.batchtutorial.dto;

import com.example.batchtutorial.entity.Customer;
import com.example.batchtutorial.entity.Order;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * 주문 처리 결과를 담는 DTO
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProcessedOrderDto {
    
    private Order order;
    private Customer customer;
    private LocalDateTime processedAt;
    private BigDecimal pointsEarned;
    private String notificationMessage;
    
    // 알림 메시지 생성
    public String generateNotificationMessage() {
        if (notificationMessage == null) {
            notificationMessage = String.format(
                "안녕하세요 %s님! 주문번호 %s이 처리되었습니다. %s 포인트가 적립되었습니다.",
                customer.getName(),
                order.getOrderNumber(),
                pointsEarned
            );
        }
        return notificationMessage;
    }
}
```

### 4. Composite ItemWriter
```java
package com.example.batchtutorial.batch.writer;

import com.example.batchtutorial.dto.ProcessedOrderDto;
import com.example.batchtutorial.entity.DailySales;
import com.example.batchtutorial.repository.CustomerRepository;
import com.example.batchtutorial.repository.DailySalesRepository;
import com.example.batchtutorial.repository.OrderRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.item.Chunk;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

/**
 * 복합 데이터 저장을 위한 ItemWriter 설정
 */
@Slf4j
@Configuration
public class OrderItemWriterConfig {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private CustomerRepository customerRepository;
    
    @Autowired
    private DailySalesRepository dailySalesRepository;
    
    /**
     * 처리된 주문 데이터를 여러 테이블에 저장하는 Writer
     */
    @Bean
    public ItemWriter<ProcessedOrderDto> processedOrderWriter() {
        return new ItemWriter<ProcessedOrderDto>() {
            @Override
            public void write(Chunk<? extends ProcessedOrderDto> chunk) throws Exception {
                
                List<? extends ProcessedOrderDto> items = chunk.getItems();
                log.info("Writing {} processed orders", items.size());
                
                int savedOrders = 0;
                int updatedCustomers = 0;
                int statisticsUpdated = 0;
                int notificationsSent = 0;
                
                for (ProcessedOrderDto dto : items) {
                    try {
                        // 1. 주문 상태 업데이트
                        orderRepository.save(dto.getOrder());
                        savedOrders++;
                        
                        // 2. 고객 정보 업데이트
                        customerRepository.save(dto.getCustomer());
                        updatedCustomers++;
                        
                        // 3. 일일 매출 통계 업데이트
                        updateDailySalesStatistics(dto);
                        statisticsUpdated++;
                        
                        // 4. 알림 발송 (로그만 기록)
                        sendNotification(dto);
                        notificationsSent++;
                        
                        log.debug("Successfully wrote order: {}", dto.getOrder().getOrderNumber());
                        
                    } catch (Exception e) {
                        log.error("Failed to write processed order {}: {}", 
                                dto.getOrder().getOrderNumber(), e.getMessage(), e);
                        throw e;  // 예외 발생 시 전체 청크 롤백
                    }
                }
                
                log.info("Chunk write completed - Orders: {}, Customers: {}, Stats: {}, Notifications: {}", 
                        savedOrders, updatedCustomers, statisticsUpdated, notificationsSent);
            }
        };
    }
    
    /**
     * 일일 매출 통계 업데이트
     */
    private void updateDailySalesStatistics(ProcessedOrderDto dto) {
        LocalDate orderDate = dto.getOrder().getOrderDate().toLocalDate();
        
        Optional<DailySales> existingSalesOpt = dailySalesRepository.findBySalesDate(orderDate);
        
        DailySales dailySales;
        if (existingSalesOpt.isPresent()) {
            dailySales = existingSalesOpt.get();
        } else {
            dailySales = new DailySales();
            dailySales.setSalesDate(orderDate);
        }
        
        // 주문 추가 (내부에서 평균 계산 수행)
        dailySales.addOrder(dto.getOrder().getTotalAmount());
        
        // 저장
        dailySalesRepository.save(dailySales);
        
        log.debug("Updated daily sales for {}: {} orders, total amount {}", 
                orderDate, dailySales.getTotalOrders(), dailySales.getTotalAmount());
    }
    
    /**
     * 알림 발송 (실제로는 로그만 기록)
     */
    private void sendNotification(ProcessedOrderDto dto) {
        String message = dto.generateNotificationMessage();
        
        // 실제 환경에서는 이메일, SMS, 푸시 알림 등을 발송
        log.info("📧 [NOTIFICATION] {}", message);
        
        // 알림 발송 실패 시뮬레이션 (랜덤하게)
        if (Math.random() < 0.1) {  // 10% 확률로 실패
            log.warn("⚠️ Notification delivery failed for order: {}", dto.getOrder().getOrderNumber());
            // 실제로는 재시도 큐에 넣거나 별도 처리
        }
    }
}
```

## 🔄 조건부 Step과 Flow 제어

### 메인 배치 설정
```java
package com.example.batchtutorial.config;

import com.example.batchtutorial.dto.ProcessedOrderDto;
import com.example.batchtutorial.entity.Order;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.*;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.job.flow.FlowExecutionStatus;
import org.springframework.batch.core.job.flow.JobExecutionDecider;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.PlatformTransactionManager;

/**
 * 고급 주문 처리 배치 설정
 */
@Slf4j
@Configuration
public class AdvancedOrderBatchConfig {
    
    @Autowired
    private JobRepository jobRepository;
    
    @Autowired
    private PlatformTransactionManager transactionManager;
    
    /**
     * 메인 주문 처리 Job (조건부 실행 포함)
     */
    @Bean
    public Job processOrdersJob(Step processOrdersStep, 
                               Step generateReportsStep,
                               Step sendSummaryNotificationStep,
                               JobExecutionDecider orderProcessingDecider) {
        return new JobBuilder("processOrdersJob", jobRepository)
                .incrementer(new RunIdIncrementer())
                .start(processOrdersStep)
                .next(orderProcessingDecider)                    // 처리 결과에 따라 분기
                .from(orderProcessingDecider).on("CONTINUE")     // 성공 시 계속
                    .to(generateReportsStep)
                    .next(sendSummaryNotificationStep)
                .from(orderProcessingDecider).on("STOP")         // 처리할 데이터 없음
                    .end()
                .build();
    }
    
    /**
     * 주문 처리 Step
     */
    @Bean
    public Step processOrdersStep(
            @Qualifier("pendingOrderReader") ItemReader<Order> reader,
            ItemProcessor<Order, ProcessedOrderDto> processor,
            ItemWriter<ProcessedOrderDto> writer) {
        
        return new StepBuilder("processOrdersStep", jobRepository)
                .<Order, ProcessedOrderDto>chunk(5, transactionManager)
                .reader(reader)
                .processor(processor)  
                .writer(writer)
                // 고급 에러 처리 설정
                .faultTolerant()
                .skipLimit(10)                                 // 최대 10개 스킵 허용
                .skip(Exception.class)                         // 모든 예외에 대해 스킵
                .noSkip(OutOfMemoryError.class)               // OOM은 스킵 안함
                .retryLimit(3)                                 // 최대 3번 재시도
                .retry(org.springframework.dao.TransientDataAccessException.class)
                .listener(orderProcessingStepListener())       // Step 리스너 등록
                .build();
    }
    
    /**
     * 리포트 생성 Step
     */
    @Bean
    public Step generateReportsStep() {
        return new StepBuilder("generateReportsStep", jobRepository)
                .tasklet((contribution, chunkContext) -> {
                    log.info("📊 Generating daily reports...");
                    
                    // 실제로는 리포트 생성 로직 구현
                    Thread.sleep(2000);  // 처리 시간 시뮬레이션
                    
                    log.info("✅ Daily reports generated successfully");
                    return RepeatStatus.FINISHED;
                }, transactionManager)
                .build();
    }
    
    /**
     * 요약 알림 발송 Step
     */
    @Bean
    public Step sendSummaryNotificationStep() {
        return new StepBuilder("sendSummaryNotificationStep", jobRepository)
                .tasklet((contribution, chunkContext) -> {
                    JobExecution jobExecution = contribution.getStepExecution().getJobExecution();
                    
                    // Job 실행 통계 정보 수집
                    StepExecution processOrdersStep = jobExecution.getStepExecutions()
                            .stream()
                            .filter(step -> "processOrdersStep".equals(step.getStepName()))
                            .findFirst()
                            .orElse(null);
                    
                    if (processOrdersStep != null) {
                        int processedCount = processOrdersStep.getWriteCount();
                        int skippedCount = processOrdersStep.getSkipCount();
                        
                        String summary = String.format(
                            "📈 Order Processing Summary:\n" +
                            "✅ Processed: %d orders\n" +
                            "⚠️ Skipped: %d orders\n" +
                            "⏱️ Duration: %d ms",
                            processedCount, skippedCount,
                            processOrdersStep.getEndTime().getTime() - processOrdersStep.getStartTime().getTime()
                        );
                        
                        log.info(summary);
                        
                        // 실제로는 관리자에게 이메일 발송
                        log.info("📧 Summary notification sent to administrators");
                    }
                    
                    return RepeatStatus.FINISHED;
                }, transactionManager)
                .build();
    }
    
    /**
     * 주문 처리 결과에 따른 Flow 제어 Decider
     */
    @Bean
    public JobExecutionDecider orderProcessingDecider() {
        return new JobExecutionDecider() {
            @Override
            public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) {
                
                if (stepExecution == null) {
                    return new FlowExecutionStatus("STOP");
                }
                
                int processedCount = stepExecution.getWriteCount();
                ExitStatus exitStatus = stepExecution.getExitStatus();
                
                log.info("🤔 Decision point - Processed: {}, Exit status: {}", 
                        processedCount, exitStatus.getExitCode());
                
                // 처리된 주문이 있고 성공적으로 완료된 경우 계속 진행
                if (processedCount > 0 && ExitStatus.COMPLETED.equals(exitStatus)) {
                    log.info("➡️ Continuing to report generation");
                    return new FlowExecutionStatus("CONTINUE");
                } else {
                    log.info("⏹️ Stopping job - No orders processed or step failed");
                    return new FlowExecutionStatus("STOP");
                }
            }
        };
    }
    
    /**
     * 주문 처리 Step 리스너
     */
    @Bean
    public OrderProcessingStepListener orderProcessingStepListener() {
        return new OrderProcessingStepListener();
    }
}
```

### Step 리스너
```java
package com.example.batchtutorial.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.StepExecutionListener;
import org.springframework.stereotype.Component;

/**
 * 주문 처리 Step의 실행 상태를 모니터링하는 리스너
 */
@Slf4j
@Component
public class OrderProcessingStepListener implements StepExecutionListener {
    
    @Override
    public void beforeStep(StepExecution stepExecution) {
        log.info("🚀 Starting order processing step: {}", stepExecution.getStepName());
        log.info("📋 Job parameters: {}", stepExecution.getJobParameters());
    }
    
    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        long duration = stepExecution.getEndTime().getTime() - stepExecution.getStartTime().getTime();
        
        log.info("✅ Order processing step completed: {}", stepExecution.getStepName());
        log.info("📊 Processing statistics:");
        log.info("   - Read count: {}", stepExecution.getReadCount());
        log.info("   - Write count: {}", stepExecution.getWriteCount());
        log.info("   - Skip count: {}", stepExecution.getSkipCount());
        log.info("   - Filter count: {}", stepExecution.getFilterCount());
        log.info("   - Duration: {} ms", duration);
        
        // 처리 성능 평가
        if (duration > 60000) {  // 1분 이상
            log.warn("⚠️ Step execution took longer than expected: {} ms", duration);
        }
        
        if (stepExecution.getSkipCount() > 0) {
            log.warn("⚠️ {} orders were skipped during processing", stepExecution.getSkipCount());
        }
        
        return stepExecution.getExitStatus();
    }
}
```

## 🧪 테스트 데이터 및 실행

### 테스트 데이터 생성 (data.sql)
```sql
-- src/main/resources/data.sql

-- 고객 데이터
INSERT INTO customers (name, email, phone, grade, total_points, total_purchase_amount, created_at, updated_at) VALUES
('김철수', 'kim@example.com', '010-1234-5678', 'BRONZE', 0, 0, NOW(), NOW()),
('이영희', 'lee@example.com', '010-2345-6789', 'SILVER', 5000, 150000, NOW(), NOW()),
('박민수', 'park@example.com', '010-3456-7890', 'GOLD', 12000, 600000, NOW(), NOW());

-- 상품 데이터
INSERT INTO products (name, price, stock_quantity, category, is_active, created_at, updated_at) VALUES
('노트북', 1200000, 50, '전자제품', true, NOW(), NOW()),
('스마트폰', 800000, 100, '전자제품', true, NOW(), NOW()),
('책상', 300000, 20, '가구', true, NOW(), NOW()),
('의자', 150000, 30, '가구', true, NOW(), NOW());

-- 주문 데이터
INSERT INTO orders (customer_id, order_number, status, total_amount, order_date, created_at, updated_at) VALUES
(1, 'ORD-001', 'PENDING', 1200000, '2024-08-25 10:00:00', NOW(), NOW()),
(2, 'ORD-002', 'PENDING', 800000, '2024-08-25 11:00:00', NOW(), NOW()),
(3, 'ORD-003', 'PENDING', 450000, '2024-08-25 12:00:00', NOW(), NOW());

-- 주문 아이템 데이터
INSERT INTO order_items (order_id, product_id, product_name, quantity, unit_price, total_price) VALUES
(1, 1, '노트북', 1, 1200000, 1200000),
(2, 2, '스마트폰', 1, 800000, 800000),
(3, 3, '책상', 1, 300000, 300000),
(3, 4, '의자', 1, 150000, 150000);
```

이제 고급 데이터베이스 연동과 복잡한 비즈니스 로직이 포함된 완전한 Spring Batch 시스템이 완성되었습니다! 다음 단계에서는 성능 최적화와 모니터링에 대해 학습하겠습니다.