# 10. ë°°ì¹˜ ê³ ê¸‰ í™œìš©ë²• ë° ì‹¤ë¬´ íŒ ì´ì •ë¦¬

## ğŸ¯ í•™ìŠµ ì´ê´„

ì´ ë¬¸ì„œëŠ” Spring Batch í•™ìŠµì˜ ìµœì¢… ë‹¨ê³„ë¡œ, **ì‹¤ë¬´ì—ì„œ í•„ìš”í•œ ê³ ê¸‰ í™œìš©ë²•ê³¼ ë…¸í•˜ìš°**ë¥¼ ì¢…í•©ì ìœ¼ë¡œ ë‹¤ë£¹ë‹ˆë‹¤.

## ğŸš€ ê³ ê¸‰ ì•„í‚¤í…ì²˜ íŒ¨í„´

### 1. ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ í™˜ê²½ì—ì„œì˜ ë°°ì¹˜
```java
/**
 * ë¶„ì‚° ë°°ì¹˜ ì‹œìŠ¤í…œ ì•„í‚¤ï¿½ecture
 */
@Configuration
@EnableScheduling
public class DistributedBatchConfig {
    
    /**
     * ë°°ì¹˜ ì‘ì—… ë¶„ì‚° ì²˜ë¦¬ë¥¼ ìœ„í•œ Message Queue ê¸°ë°˜ ì•„í‚¤í…ì²˜
     */
    @Bean
    public Job distributedProcessingJob() {
        return new JobBuilder("distributedProcessingJob", jobRepository)
            .start(dataPartitionStep())        // 1. ë°ì´í„° ë¶„í• 
            .next(messagePublishStep())        // 2. ë©”ì‹œì§€ íì— ì‘ì—… ë°œí–‰
            .next(resultAggregationStep())     // 3. ê²°ê³¼ ìˆ˜ì§‘ ë° ì§‘ê³„
            .build();
    }
    
    /**
     * Kafkaë¥¼ í†µí•œ ë°°ì¹˜ ì‘ì—… ë¶„ì‚°
     */
    @KafkaListener(topics = "batch-work-queue")
    public void processBatchWork(@Payload BatchWorkMessage message) {
        try {
            // ë¶„ì‚°ëœ ë°°ì¹˜ ì‘ì—… ì²˜ë¦¬
            JobParameters params = new JobParametersBuilder()
                .addString("workId", message.getWorkId())
                .addString("dataRange", message.getDataRange())
                .toJobParameters();
            
            jobLauncher.run(workerBatchJob, params);
            
            // ì™„ë£Œ ë©”ì‹œì§€ ë°œí–‰
            kafkaTemplate.send("batch-completion-topic", 
                new BatchCompletionMessage(message.getWorkId(), "SUCCESS"));
                
        } catch (Exception e) {
            // ì‹¤íŒ¨ ì²˜ë¦¬ ë° ì¬ì‹œë„ ë¡œì§
            handleDistributedBatchFailure(message, e);
        }
    }
}
```

### 2. ì´ë²¤íŠ¸ ê¸°ë°˜ ë°°ì¹˜ ì‹œìŠ¤í…œ
```java
/**
 * ë„ë©”ì¸ ì´ë²¤íŠ¸ ê¸°ë°˜ ë°°ì¹˜ ì²˜ë¦¬
 */
@Component
public class EventDrivenBatchManager {
    
    /**
     * ì£¼ë¬¸ ì™„ë£Œ ì´ë²¤íŠ¸ ë°œìƒ ì‹œ ìë™ ë°°ì¹˜ ì‹¤í–‰
     */
    @EventListener
    @Async
    public void handleOrderCompletedEvent(OrderCompletedEvent event) {
        // ì£¼ë¬¸ ì™„ë£Œ í›„ 1ì‹œê°„ ë’¤ ë°°ì†¡ ì¤€ë¹„ ë°°ì¹˜ ì‹¤í–‰
        scheduleDelayedBatch("shipping-preparation-job", 
                           Duration.ofHours(1), 
                           Map.of("orderId", event.getOrderId()));
    }
    
    /**
     * ì¬ê³  ë¶€ì¡± ì´ë²¤íŠ¸ ë°œìƒ ì‹œ ê¸´ê¸‰ ë°°ì¹˜ ì‹¤í–‰
     */
    @EventListener
    public void handleLowStockEvent(LowStockEvent event) {
        // ì¦‰ì‹œ ì¬ê³  ë³´ì¶© ìš”ì²­ ë°°ì¹˜ ì‹¤í–‰
        executeImmediateBatch("stock-replenishment-job", 
                            Map.of("productId", event.getProductId(),
                                   "urgentLevel", "HIGH"));
    }
    
    private void scheduleDelayedBatch(String jobName, Duration delay, Map<String, Object> params) {
        // Springì˜ TaskSchedulerë¥¼ ì‚¬ìš©í•œ ì§€ì—° ì‹¤í–‰
        taskScheduler.schedule(() -> {
            try {
                JobParameters jobParams = createJobParameters(params);
                jobLauncher.run(getJob(jobName), jobParams);
            } catch (Exception e) {
                log.error("Scheduled batch execution failed: {}", jobName, e);
                // ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ ë¡œì§ ë˜ëŠ” ì•Œë¦¼ ë°œì†¡
            }
        }, Instant.now().plus(delay));
    }
}
```

### 3. ì¡°ê±´ë¶€ ë°°ì¹˜ ì²´ì¸
```java
/**
 * ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ìœ„í•œ ì¡°ê±´ë¶€ ë°°ì¹˜ ì²´ì¸
 */
@Configuration
public class ConditionalBatchChainConfig {
    
    /**
     * ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ì— ë”°ë¥¸ ë™ì  ë°°ì¹˜ í”Œë¡œìš°
     */
    @Bean
    public Job smartProcessingJob() {
        return new JobBuilder("smartProcessingJob", jobRepository)
            .start(dataAnalysisStep())
            .next(businessRuleDecider())
            
            // ê³ ê° ë“±ê¸‰ë³„ ë¶„ê¸°
            .from(businessRuleDecider()).on("VIP_CUSTOMERS")
                .to(vipCustomerProcessingFlow())
            .from(businessRuleDecider()).on("REGULAR_CUSTOMERS")
                .to(regularCustomerProcessingFlow())
            .from(businessRuleDecider()).on("NEW_CUSTOMERS")
                .to(newCustomerOnboardingFlow())
                
            // ë°ì´í„° ë³¼ë¥¨ë³„ ë¶„ê¸°
            .from(businessRuleDecider()).on("LARGE_VOLUME")
                .to(parallelProcessingFlow())
            .from(businessRuleDecider()).on("SMALL_VOLUME")
                .to(sequentialProcessingStep())
                
            // ìµœì¢… ì§‘ê³„
            .from(vipCustomerProcessingFlow()).on("*").to(finalAggregationStep())
            .from(regularCustomerProcessingFlow()).on("*").to(finalAggregationStep())
            .from(newCustomerOnboardingFlow()).on("*").to(finalAggregationStep())
            .from(sequentialProcessingStep()).on("*").to(finalAggregationStep())
            
            .build();
    }
    
    /**
     * ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²°ì •ì
     */
    @Bean
    public JobExecutionDecider businessRuleDecider() {
        return (jobExecution, stepExecution) -> {
            
            // ë°ì´í„° ë¶„ì„ ê²°ê³¼ ì¡°íšŒ
            ExecutionContext context = stepExecution.getExecutionContext();
            int totalRecords = context.getInt("totalRecords", 0);
            String customerSegment = context.getString("primarySegment", "REGULAR");
            boolean isEndOfMonth = isEndOfMonth();
            boolean isHighTrafficPeriod = isHighTrafficPeriod();
            
            // ë³µí•© ì¡°ê±´ í‰ê°€
            if (isEndOfMonth && "VIP".equals(customerSegment)) {
                return new FlowExecutionStatus("VIP_CUSTOMERS");
            }
            
            if (totalRecords > 100000 || isHighTrafficPeriod) {
                return new FlowExecutionStatus("LARGE_VOLUME");
            }
            
            if ("NEW".equals(customerSegment)) {
                return new FlowExecutionStatus("NEW_CUSTOMERS");
            }
            
            return new FlowExecutionStatus("REGULAR_CUSTOMERS");
        };
    }
}
```

## ğŸ’¡ ì‹¤ë¬´ ì„±ëŠ¥ ìµœì í™” ê¸°ë²•

### 1. ë™ì  ì²­í¬ í¬ê¸° ì¡°ì •
```java
/**
 * ëŸ°íƒ€ì„ ì„±ëŠ¥ì— ë”°ë¥¸ ë™ì  ì²­í¬ í¬ê¸° ì¡°ì •
 */
@Component
public class AdaptiveChunkSizeManager {
    
    private final AtomicInteger currentChunkSize = new AtomicInteger(100);
    private final MovingAverage processingTimeAvg = new MovingAverage(10);
    private final MovingAverage memoryUsageAvg = new MovingAverage(5);
    
    /**
     * ì„±ëŠ¥ ë©”íŠ¸ë¦­ ê¸°ë°˜ ì²­í¬ í¬ê¸° ìë™ ì¡°ì •
     */
    public int getOptimalChunkSize() {
        double avgProcessingTime = processingTimeAvg.getAverage();
        double avgMemoryUsage = memoryUsageAvg.getAverage();
        int current = currentChunkSize.get();
        
        // ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ ì´ ë†’ìœ¼ë©´ ì²­í¬ í¬ê¸° ê°ì†Œ
        if (avgMemoryUsage > 0.8) {
            int newSize = Math.max(10, (int) (current * 0.8));
            currentChunkSize.set(newSize);
            log.info("Reducing chunk size due to high memory usage: {} -> {}", current, newSize);
            return newSize;
        }
        
        // ì²˜ë¦¬ ì‹œê°„ì´ ëª©í‘œë³´ë‹¤ ê¸¸ë©´ ì²­í¬ í¬ê¸° ê°ì†Œ
        if (avgProcessingTime > 5000) { // 5ì´ˆ ì´ˆê³¼
            int newSize = Math.max(10, (int) (current * 0.9));
            currentChunkSize.set(newSize);
            log.info("Reducing chunk size due to slow processing: {} -> {}", current, newSize);
            return newSize;
        }
        
        // ì„±ëŠ¥ì´ ì¢‹ìœ¼ë©´ ì²­í¬ í¬ê¸° ì¦ê°€ ì‹œë„
        if (avgProcessingTime < 1000 && avgMemoryUsage < 0.6) {
            int newSize = Math.min(1000, (int) (current * 1.2));
            currentChunkSize.set(newSize);
            log.info("Increasing chunk size due to good performance: {} -> {}", current, newSize);
            return newSize;
        }
        
        return current;
    }
    
    /**
     * ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
     */
    public void updateMetrics(long processingTime, double memoryUsage) {
        processingTimeAvg.add(processingTime);
        memoryUsageAvg.add(memoryUsage);
    }
}

/**
 * ë™ì  ì²­í¬ í¬ê¸°ë¥¼ ì‚¬ìš©í•˜ëŠ” Step
 */
@Bean
@JobScope
public Step adaptiveStep() {
    return new StepBuilder("adaptiveStep", jobRepository)
        .<InputData, OutputData>chunk(adaptiveChunkSizeManager::getOptimalChunkSize, transactionManager)
        .reader(reader())
        .processor(performanceAwareProcessor())
        .writer(writer())
        .listener(new ChunkPerformanceListener(adaptiveChunkSizeManager))
        .build();
}
```

### 2. ì§€ëŠ¥í˜• ë°°ì¹˜ ìŠ¤ì¼€ì¤„ë§
```java
/**
 * ì‹œìŠ¤í…œ ë¶€í•˜ì™€ ë¹„ì¦ˆë‹ˆìŠ¤ ìš°ì„ ìˆœìœ„ë¥¼ ê³ ë ¤í•œ ìŠ¤ë§ˆíŠ¸ ìŠ¤ì¼€ì¤„ë§
 */
@Component
@EnableScheduling
public class IntelligentBatchScheduler {
    
    private final PriorityQueue<ScheduledBatch> batchQueue = new PriorityQueue<>(
        Comparator.comparing(ScheduledBatch::getPriority).reversed()
            .thenComparing(ScheduledBatch::getScheduledTime)
    );
    
    /**
     * ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ìƒíƒœ ê¸°ë°˜ ë°°ì¹˜ ì‹¤í–‰ ê²°ì •
     */
    @Scheduled(fixedDelay = 30000) // 30ì´ˆë§ˆë‹¤ ì²´í¬
    public void executeScheduledBatches() {
        SystemResourceInfo resources = getSystemResources();
        
        // ì‹œìŠ¤í…œ ë¶€í•˜ê°€ ë†’ìœ¼ë©´ ì¤‘ìš”í•œ ë°°ì¹˜ë§Œ ì‹¤í–‰
        if (resources.getCpuUsage() > 80 || resources.getMemoryUsage() > 85) {
            log.warn("High system load detected. Only critical batches will run.");
            executeCriticalBatchesOnly();
            return;
        }
        
        // ë¹„ì¦ˆë‹ˆìŠ¤ ì‹œê°„ëŒ€ë³„ ì‹¤í–‰ ì •ì±…
        LocalTime now = LocalTime.now();
        if (isBusinessHours(now)) {
            // ì—…ë¬´ì‹œê°„: ê°€ë²¼ìš´ ë°°ì¹˜ë§Œ ì‹¤í–‰
            executeLeightweightBatches(resources);
        } else {
            // ì•¼ê°„/ì£¼ë§: ëª¨ë“  ë°°ì¹˜ ì‹¤í–‰ ê°€ëŠ¥
            executeAllPendingBatches(resources);
        }
    }
    
    /**
     * ë™ì  ìš°ì„ ìˆœìœ„ ê³„ì‚°
     */
    private int calculateDynamicPriority(BatchJobInfo jobInfo) {
        int basePriority = jobInfo.getBasePriority();
        
        // SLA ë°ë“œë¼ì¸ ì ‘ê·¼ë„
        Duration timeToDeadline = Duration.between(LocalDateTime.now(), jobInfo.getDeadline());
        if (timeToDeadline.toHours() < 2) {
            basePriority += 50; // ê¸‰ìƒìŠ¹
        } else if (timeToDeadline.toHours() < 6) {
            basePriority += 20;
        }
        
        // ì¬ì‹œë„ íšŸìˆ˜ì— ë”°ë¥¸ ìš°ì„ ìˆœìœ„ ê°ì†Œ
        basePriority -= (jobInfo.getRetryCount() * 5);
        
        // ë°ì´í„° ì˜ì¡´ì„± ì²´í¬
        if (hasWaitingDependentJobs(jobInfo)) {
            basePriority += 30;
        }
        
        return Math.max(0, basePriority);
    }
    
    /**
     * ìŠ¤ë§ˆíŠ¸ ë¦¬ì†ŒìŠ¤ í• ë‹¹
     */
    private ExecutionPlan createExecutionPlan(List<ScheduledBatch> batches, SystemResourceInfo resources) {
        ExecutionPlan plan = new ExecutionPlan();
        
        // ë©”ëª¨ë¦¬ ì§‘ì•½ì  vs CPU ì§‘ì•½ì  ë°°ì¹˜ ë¶„ë¥˜
        List<ScheduledBatch> memoryIntensive = batches.stream()
            .filter(b -> b.getResourceProfile().isMemoryIntensive())
            .toList();
            
        List<ScheduledBatch> cpuIntensive = batches.stream()
            .filter(b -> b.getResourceProfile().isCpuIntensive())
            .toList();
        
        // ë¦¬ì†ŒìŠ¤ë³„ ìµœì  ìŠ¤ì¼€ì¤„ë§
        if (resources.getMemoryUsage() < 60) {
            plan.addParallelExecution(memoryIntensive, 2); // ë©”ëª¨ë¦¬ ì¶©ë¶„í•˜ë©´ ë³‘ë ¬ ì‹¤í–‰
        } else {
            plan.addSequentialExecution(memoryIntensive); // ìˆœì°¨ ì‹¤í–‰
        }
        
        if (resources.getCpuUsage() < 50) {
            plan.addParallelExecution(cpuIntensive, 4); // CPU ì—¬ìœ ë¡­ë©´ ë†’ì€ ë³‘ë ¬ë„
        } else {
            plan.addParallelExecution(cpuIntensive, 2); // ì œí•œëœ ë³‘ë ¬ë„
        }
        
        return plan;
    }
}
```

### 3. ë©”ëª¨ë¦¬ ìµœì í™” ItemReader
```java
/**
 * ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ë¥¼ ìœ„í•œ ë©”ëª¨ë¦¬ íš¨ìœ¨ì  ItemReader
 */
public class OptimizedLargeDataReader implements ItemReader<DataRecord> {
    
    private final DataSource dataSource;
    private final String query;
    private final int fetchSize;
    private Connection connection;
    private PreparedStatement statement;
    private ResultSet resultSet;
    private boolean initialized = false;
    
    public OptimizedLargeDataReader(DataSource dataSource, String query, int fetchSize) {
        this.dataSource = dataSource;
        this.query = query;
        this.fetchSize = fetchSize;
    }
    
    @Override
    public DataRecord read() throws Exception {
        if (!initialized) {
            initialize();
        }
        
        if (resultSet.next()) {
            return mapResultSetToRecord(resultSet);
        } else {
            // ë©”ëª¨ë¦¬ í•´ì œ
            closeResources();
            return null;
        }
    }
    
    private void initialize() throws SQLException {
        connection = dataSource.getConnection();
        
        // ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±ì„ ìœ„í•œ ì„¤ì •
        connection.setAutoCommit(false);
        statement = connection.prepareStatement(query, 
                                              ResultSet.TYPE_FORWARD_ONLY, 
                                              ResultSet.CONCUR_READ_ONLY);
        
        // MySQL/PostgreSQL ìŠ¤íŠ¸ë¦¬ë° ì„¤ì •
        statement.setFetchSize(fetchSize);
        if (connection.getMetaData().getDriverName().contains("mysql")) {
            statement.setFetchSize(Integer.MIN_VALUE); // MySQL streaming
        }
        
        resultSet = statement.executeQuery();
        initialized = true;
        
        log.info("Initialized streaming reader with fetch size: {}", fetchSize);
    }
    
    /**
     * ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§
     */
    @PreDestroy
    public void monitorMemoryUsage() {
        Runtime runtime = Runtime.getRuntime();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        long maxMemory = runtime.maxMemory();
        double usagePercentage = (double) usedMemory / maxMemory * 100;
        
        if (usagePercentage > 85) {
            log.warn("High memory usage detected: {:.1f}%. Consider reducing fetch size.", usagePercentage);
            
            // ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ íŒíŠ¸
            runtime.gc();
        }
    }
}
```

## ğŸ›¡ï¸ í”„ë¡œë•ì…˜ ìš´ì˜ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

### 1. ë°°ì¹˜ ë³´ì•ˆ ê°•í™”
```java
/**
 * ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ë°°ì¹˜ ë³´ì•ˆ ì„¤ì •
 */
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class BatchSecurityConfig {
    
    /**
     * ë°°ì¹˜ ì‹¤í–‰ ê¶Œí•œ ì œì–´
     */
    @Bean
    public JobOperatorSecurityWrapper secureJobOperator(JobOperator jobOperator) {
        return new JobOperatorSecurityWrapper(jobOperator);
    }
    
    /**
     * ë°ì´í„° ì•”í˜¸í™”ë¥¼ ìœ„í•œ ItemProcessor
     */
    @Bean
    public ItemProcessor<SensitiveData, SensitiveData> encryptionProcessor() {
        return item -> {
            // ë¯¼ê°í•œ ë°ì´í„° ì•”í˜¸í™”
            if (item.containsSensitiveInformation()) {
                item.setEncryptedData(encryptionService.encrypt(item.getSensitiveData()));
                item.clearPlainTextData(); // ì›ë³¸ ë°ì´í„° ì‚­ì œ
            }
            
            // ë°ì´í„° ë§ˆìŠ¤í‚¹ (ë¡œê·¸ìš©)
            item.setMaskedData(maskingService.maskSensitiveFields(item));
            
            return item;
        };
    }
    
    /**
     * ê°ì‚¬ ë¡œê·¸ ê¸°ë¡
     */
    @Component
    public class BatchAuditLogger implements JobExecutionListener {
        
        @Override
        public void beforeJob(JobExecution jobExecution) {
            auditService.logBatchStart(
                jobExecution.getJobInstance().getJobName(),
                SecurityContextHolder.getContext().getAuthentication().getName(),
                extractSensitiveParameters(jobExecution.getJobParameters())
            );
        }
        
        @Override
        public void afterJob(JobExecution jobExecution) {
            auditService.logBatchCompletion(
                jobExecution.getId(),
                jobExecution.getStatus(),
                calculateDataAccessSummary(jobExecution)
            );
        }
        
        private DataAccessSummary calculateDataAccessSummary(JobExecution jobExecution) {
            return jobExecution.getStepExecutions().stream()
                .collect(DataAccessSummary.collector());
        }
    }
}
```

### 2. ë°°ì¹˜ ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§
```java
/**
 * ì‹¤ì‹œê°„ ë°°ì¹˜ ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§ ì‹œìŠ¤í…œ
 */
@Component
public class BatchPerformanceProfiler {
    
    private final MeterRegistry meterRegistry;
    private final Map<String, Timer.Sample> activeTimers = new ConcurrentHashMap<>();
    
    /**
     * ìƒì„¸ ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
     */
    @EventListener
    public void handleStepStart(StepExecutionEvent event) {
        String stepName = event.getStepExecution().getStepName();
        
        // íƒ€ì´ë¨¸ ì‹œì‘
        Timer.Sample sample = Timer.start(meterRegistry);
        activeTimers.put(stepName, sample);
        
        // ë©”ëª¨ë¦¬ ìŠ¤ëƒ…ìƒ·
        recordMemorySnapshot(stepName + ".start");
        
        // CPU ì‚¬ìš©ë¥  ëª¨ë‹ˆí„°ë§ ì‹œì‘
        startCpuMonitoring(stepName);
    }
    
    @EventListener
    public void handleStepEnd(StepExecutionEvent event) {
        String stepName = event.getStepExecution().getStepName();
        StepExecution execution = event.getStepExecution();
        
        // íƒ€ì´ë¨¸ ì¢…ë£Œ
        Timer.Sample sample = activeTimers.remove(stepName);
        if (sample != null) {
            sample.stop(Timer.builder("batch.step.duration")
                .tag("step", stepName)
                .tag("status", execution.getStatus().toString())
                .register(meterRegistry));
        }
        
        // ì²˜ë¦¬ëŸ‰ ë©”íŠ¸ë¦­
        recordThroughputMetrics(stepName, execution);
        
        // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë³€í™”
        recordMemorySnapshot(stepName + ".end");
        
        // ì„±ëŠ¥ ë¶„ì„ ë¦¬í¬íŠ¸ ìƒì„±
        generatePerformanceReport(stepName, execution);
    }
    
    /**
     * ì‹¤ì‹œê°„ ì„±ëŠ¥ ë¶„ì„ ë° ì•Œë¦¼
     */
    private void generatePerformanceReport(String stepName, StepExecution execution) {
        PerformanceReport report = PerformanceReport.builder()
            .stepName(stepName)
            .duration(calculateDuration(execution))
            .throughput(calculateThroughput(execution))
            .memoryUsed(calculateMemoryDelta(stepName))
            .errorRate(calculateErrorRate(execution))
            .build();
        
        // ì„±ëŠ¥ ì„ê³„ê°’ ì²´í¬
        if (report.getThroughput() < getExpectedThroughput(stepName) * 0.8) {
            alertService.sendPerformanceAlert(
                "Low throughput detected in step: " + stepName,
                report
            );
        }
        
        // ì„±ëŠ¥ íˆìŠ¤í† ë¦¬ ì €ì¥
        performanceHistoryService.save(report);
    }
    
    /**
     * ì„±ëŠ¥ íŠ¸ë Œë“œ ë¶„ì„
     */
    @Scheduled(fixedRate = 300000) // 5ë¶„ë§ˆë‹¤
    public void analyzePerfomanceTrends() {
        List<PerformanceReport> recentReports = 
            performanceHistoryService.getRecentReports(Duration.ofHours(1));
        
        for (String stepName : getActiveStepNames()) {
            List<PerformanceReport> stepReports = recentReports.stream()
                .filter(r -> r.getStepName().equals(stepName))
                .sorted(Comparator.comparing(PerformanceReport::getTimestamp))
                .toList();
            
            if (stepReports.size() < 3) continue;
            
            // ì„±ëŠ¥ ì €í•˜ íŠ¸ë Œë“œ íƒì§€
            if (isPerformanceDegrading(stepReports)) {
                alertService.sendTrendAlert(
                    "Performance degradation trend detected in step: " + stepName,
                    calculateTrendAnalysis(stepReports)
                );
            }
        }
    }
}
```

### 3. ê³ ê¸‰ ë°ì´í„° ê²€ì¦ ì‹œìŠ¤í…œ
```java
/**
 * ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ë°ì´í„° í’ˆì§ˆ ë³´ì¥ ì‹œìŠ¤í…œ
 */
@Component
public class DataQualityManager {
    
    /**
     * ë‹¤ì¸µ ë°ì´í„° ê²€ì¦ ì²´ê³„
     */
    public class MultiLevelValidationProcessor implements ItemProcessor<RawData, ValidatedData> {
        
        private final List<DataValidator> validators;
        private final DataQualityReporter reporter;
        
        @Override
        public ValidatedData process(RawData item) throws Exception {
            ValidationContext context = new ValidationContext(item);
            
            // 1ë‹¨ê³„: ê¸°ë³¸ ìŠ¤í‚¤ë§ˆ ê²€ì¦
            ValidationResult schemaResult = validateSchema(item, context);
            if (!schemaResult.isValid()) {
                reporter.recordValidationFailure("SCHEMA", item, schemaResult.getErrors());
                return null; // ìŠ¤í‚¤ë§ˆ ì˜¤ë¥˜ëŠ” ì²˜ë¦¬ ë¶ˆê°€
            }
            
            // 2ë‹¨ê³„: ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦
            ValidationResult businessResult = validateBusinessRules(item, context);
            if (!businessResult.isValid()) {
                // ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ìœ„ë°˜ì€ quarantineìœ¼ë¡œ ë¶„ë¥˜
                return createQuarantineRecord(item, businessResult.getErrors());
            }
            
            // 3ë‹¨ê³„: ë°ì´í„° ì¼ê´€ì„± ê²€ì¦
            ValidationResult consistencyResult = validateDataConsistency(item, context);
            if (!consistencyResult.isValid()) {
                // ì¼ê´€ì„± ë¬¸ì œëŠ” ìˆ˜ì • ì‹œë„
                item = attemptDataCorrection(item, consistencyResult.getErrors());
            }
            
            // 4ë‹¨ê³„: í’ˆì§ˆ ì ìˆ˜ ê³„ì‚°
            double qualityScore = calculateQualityScore(item, context);
            
            ValidatedData result = new ValidatedData(item);
            result.setQualityScore(qualityScore);
            result.setValidationTimestamp(LocalDateTime.now());
            
            // í’ˆì§ˆ ë©”íŠ¸ë¦­ ê¸°ë¡
            reporter.recordQualityMetrics(result);
            
            return result;
        }
        
        /**
         * AI/ML ê¸°ë°˜ ë°ì´í„° í’ˆì§ˆ ì˜ˆì¸¡
         */
        private double predictDataQuality(RawData item) {
            // ë¨¸ì‹ ëŸ¬ë‹ ëª¨ë¸ì„ ì‚¬ìš©í•œ í’ˆì§ˆ ì˜ˆì¸¡
            return qualityPredictionModel.predict(
                extractQualityFeatures(item)
            );
        }
    }
    
    /**
     * ì‹¤ì‹œê°„ ë°ì´í„° í’ˆì§ˆ ëŒ€ì‹œë³´ë“œ
     */
    @RestController
    @RequestMapping("/api/data-quality")
    public class DataQualityController {
        
        @GetMapping("/dashboard")
        public DataQualityDashboard getQualityDashboard() {
            return DataQualityDashboard.builder()
                .overallQualityScore(calculateOverallQualityScore())
                .qualityTrends(getQualityTrends(Duration.ofDays(7)))
                .topQualityIssues(getTopQualityIssues(10))
                .qualityByDataSource(getQualityByDataSource())
                .qualityImprovement(getQualityImprovementSuggestions())
                .build();
        }
        
        @GetMapping("/quality-rules")
        public List<DataQualityRule> getActiveQualityRules() {
            return dataQualityRuleManager.getActiveRules();
        }
        
        @PostMapping("/quality-rules")
        public ResponseEntity<DataQualityRule> createQualityRule(@RequestBody DataQualityRule rule) {
            DataQualityRule created = dataQualityRuleManager.createRule(rule);
            return ResponseEntity.ok(created);
        }
    }
}
```

## ğŸ“ˆ ë¹„ì¦ˆë‹ˆìŠ¤ ê°€ì¹˜ ê·¹ëŒ€í™”

### 1. ë°°ì¹˜ ROI ì¸¡ì • ì‹œìŠ¤í…œ
```java
/**
 * ë°°ì¹˜ ì‹œìŠ¤í…œì˜ ë¹„ì¦ˆë‹ˆìŠ¤ ê°€ì¹˜ ì¸¡ì •
 */
@Service
public class BatchBusinessValueCalculator {
    
    /**
     * ë°°ì¹˜ ì‹œìŠ¤í…œ ROI ê³„ì‚°
     */
    public BatchROIReport calculateBatchROI(String jobName, Period period) {
        
        // 1. ë¹„ìš© ê³„ì‚°
        BatchCostInfo costs = calculateBatchCosts(jobName, period);
        
        // 2. íš¨ìµ ê³„ì‚°
        BatchBenefitInfo benefits = calculateBatchBenefits(jobName, period);
        
        // 3. ROI ê³„ì‚°
        double roi = (benefits.getTotalValue() - costs.getTotalCost()) / costs.getTotalCost() * 100;
        
        return BatchROIReport.builder()
            .jobName(jobName)
            .period(period)
            .totalCosts(costs)
            .totalBenefits(benefits)
            .roi(roi)
            .paybackPeriod(calculatePaybackPeriod(costs, benefits))
            .recommendations(generateOptimizationRecommendations(costs, benefits))
            .build();
    }
    
    private BatchBenefitInfo calculateBatchBenefits(String jobName, Period period) {
        return BatchBenefitInfo.builder()
            // ìë™í™”ë¡œ ì¸í•œ ì¸ë ¥ ì ˆì•½
            .laborCostSaving(calculateLaborCostSaving(jobName, period))
            // ì²˜ë¦¬ ì‹œê°„ ë‹¨ì¶•ìœ¼ë¡œ ì¸í•œ ê¸°íšŒë¹„ìš© ì ˆì•½
            .timeSaving(calculateTimeSavingValue(jobName, period))
            // ì˜¤ë¥˜ ê°ì†Œë¡œ ì¸í•œ ë¹„ìš© ì ˆì•½
            .errorReductionValue(calculateErrorReductionValue(jobName, period))
            // ê³ ê° ë§Œì¡±ë„ í–¥ìƒ ê°€ì¹˜
            .customerSatisfactionValue(calculateCustomerSatisfactionValue(jobName, period))
            // ì»´í”Œë¼ì´ì–¸ìŠ¤ ì¤€ìˆ˜ ê°€ì¹˜
            .complianceValue(calculateComplianceValue(jobName, period))
            .build();
    }
    
    /**
     * ë°°ì¹˜ ì„±ëŠ¥ê³¼ ë¹„ì¦ˆë‹ˆìŠ¤ KPI ì—°ê²°
     */
    public BusinessImpactAnalysis analyzeBatchBusinessImpact(String jobName) {
        
        // ë°°ì¹˜ ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
        BatchPerformanceMetrics performance = getRecentPerformanceMetrics(jobName);
        
        // ë¹„ì¦ˆë‹ˆìŠ¤ KPIì™€ì˜ ìƒê´€ê´€ê³„ ë¶„ì„
        List<KPICorrelation> correlations = analyzeKPICorrelations(jobName, performance);
        
        // ê°œì„  ê¸°íšŒ ì‹ë³„
        List<ImprovementOpportunity> opportunities = identifyImprovementOpportunities(correlations);
        
        return BusinessImpactAnalysis.builder()
            .jobName(jobName)
            .performanceMetrics(performance)
            .kpiCorrelations(correlations)
            .improvementOpportunities(opportunities)
            .estimatedBusinessImpact(calculateEstimatedImpact(opportunities))
            .build();
    }
}
```

### 2. ì§€ì†ì  ê°œì„  ì‹œìŠ¤í…œ
```java
/**
 * ë°°ì¹˜ ì‹œìŠ¤í…œ ì§€ì†ì  ê°œì„  ìë™í™”
 */
@Component
public class ContinuousImprovementEngine {
    
    /**
     * A/B í…ŒìŠ¤íŠ¸ ê¸°ë°˜ ë°°ì¹˜ ìµœì í™”
     */
    @Scheduled(cron = "0 0 2 * * SUN") // ë§¤ì£¼ ì¼ìš”ì¼ ìƒˆë²½ 2ì‹œ
    public void runWeeklyOptimizationExperiments() {
        
        List<String> jobNames = getActiveJobNames();
        
        for (String jobName : jobNames) {
            // í˜„ì¬ ì„±ëŠ¥ ë² ì´ìŠ¤ë¼ì¸ ì„¤ì •
            PerformanceBaseline baseline = establishPerformanceBaseline(jobName);
            
            // ìµœì í™” ì‹¤í—˜ í›„ë³´ ìƒì„±
            List<OptimizationExperiment> experiments = generateOptimizationExperiments(jobName, baseline);
            
            for (OptimizationExperiment experiment : experiments) {
                // ì‹¤í—˜ í™˜ê²½ì—ì„œ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
                ExperimentResult result = runOptimizationExperiment(experiment);
                
                // ê²°ê³¼ ë¶„ì„
                if (result.isSignificantImprovement()) {
                    // í”„ë¡œë•ì…˜ ì ìš© ì œì•ˆ
                    proposeProductionDeployment(experiment, result);
                }
                
                // ì‹¤í—˜ ê²°ê³¼ ì €ì¥
                optimizationHistoryService.save(experiment, result);
            }
        }
    }
    
    /**
     * ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë°˜ ì„±ëŠ¥ ì˜ˆì¸¡ ë° ìµœì í™”
     */
    public class MLBasedOptimizer {
        
        private final MachineLearningModel performancePredictionModel;
        private final MachineLearningModel configurationOptimizationModel;
        
        /**
         * ì„±ëŠ¥ ì˜ˆì¸¡ ê¸°ë°˜ ì‚¬ì „ ìµœì í™”
         */
        public void predictiveOptimization(String jobName) {
            
            // ê³¼ê±° ì„±ëŠ¥ ë°ì´í„° ìˆ˜ì§‘
            List<PerformanceRecord> historicalData = getHistoricalPerformance(jobName, Duration.ofDays(90));
            
            // ë¯¸ë˜ ì›Œí¬ë¡œë“œ ì˜ˆì¸¡
            WorkloadForecast forecast = predictFutureWorkload(jobName, Duration.ofDays(7));
            
            // ìµœì  ì„¤ì • ì˜ˆì¸¡
            BatchConfiguration optimalConfig = configurationOptimizationModel.predict(
                OptimizationInput.builder()
                    .historicalPerformance(historicalData)
                    .forecastedWorkload(forecast)
                    .systemConstraints(getCurrentSystemConstraints())
                    .businessRequirements(getBusinessRequirements(jobName))
                    .build()
            );
            
            // ì˜ˆì¸¡ëœ ìµœì  ì„¤ì • ì ìš© ì œì•ˆ
            if (isSignificantConfigurationChange(optimalConfig)) {
                proposeConfigurationChange(jobName, optimalConfig);
            }
        }
    }
}
```

## ğŸ“ Spring Batch í•™ìŠµ ë¡œë“œë§µ ì™„ì„±

### ì‹¤ë ¥ ìˆ˜ì¤€ë³„ ì²´í¬ë¦¬ìŠ¤íŠ¸

#### ğŸ”° ì´ˆê¸‰ (Beginner)
- [ ] Spring Batch ê¸°ë³¸ ê°œë… ì´í•´ (Job, Step, ItemReader/Processor/Writer)
- [ ] ê°„ë‹¨í•œ CSV â†’ DB ë°°ì¹˜ êµ¬í˜„
- [ ] H2 ë°ì´í„°ë² ì´ìŠ¤ë¡œ ë¡œì»¬ í…ŒìŠ¤íŠ¸ í™˜ê²½ êµ¬ì¶•
- [ ] ê¸°ë³¸ì ì¸ ì—ëŸ¬ ì²˜ë¦¬ (Skip, Retry) ì´í•´
- [ ] ë°°ì¹˜ ë©”íƒ€ë°ì´í„° í…Œì´ë¸” ì´í•´

#### ğŸ¯ ì¤‘ê¸‰ (Intermediate)  
- [ ] ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ í¬í•¨ëœ ItemProcessor êµ¬í˜„
- [ ] ë°ì´í„°ë² ì´ìŠ¤ ê°„ ë°ì´í„° ì´ê´€ ë°°ì¹˜ ì‘ì„±
- [ ] ì¡°ê±´ë¶€ Step ì‹¤í–‰ ë° Flow ì œì–´
- [ ] ë©€í‹°ìŠ¤ë ˆë“œ ì²˜ë¦¬ êµ¬í˜„
- [ ] ë°°ì¹˜ ìŠ¤ì¼€ì¤„ë§ ë° ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ êµ¬ì¶•
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ë° í†µí•© í…ŒìŠ¤íŠ¸ ì‘ì„±

#### ğŸš€ ê³ ê¸‰ (Advanced)
- [ ] íŒŒí‹°ì…”ë‹ì„ í†µí•œ ëŒ€ìš©ëŸ‰ ë°ì´í„° ë¶„ì‚° ì²˜ë¦¬
- [ ] ë³µì¡í•œ ì—ëŸ¬ ì²˜ë¦¬ ì •ì±… ë° ì¬ì‹œì‘ ë©”ì»¤ë‹ˆì¦˜ êµ¬í˜„
- [ ] ì„±ëŠ¥ ìµœì í™” ë° íŠœë‹
- [ ] ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ í™˜ê²½ì—ì„œì˜ ë¶„ì‚° ë°°ì¹˜ ì‹œìŠ¤í…œ
- [ ] ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ
- [ ] ë³´ì•ˆ ë° ê°ì‚¬ ë¡œê¹… êµ¬í˜„

#### ğŸ† ì „ë¬¸ê°€ (Expert)
- [ ] ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ë°°ì¹˜ ì•„í‚¤í…ì²˜ ì„¤ê³„
- [ ] AI/ML ê¸°ë°˜ ë°°ì¹˜ ìµœì í™” ì‹œìŠ¤í…œ êµ¬ì¶•  
- [ ] í´ë¼ìš°ë“œ ë„¤ì´í‹°ë¸Œ ë°°ì¹˜ ì‹œìŠ¤í…œ ì„¤ê³„
- [ ] ë°°ì¹˜ ì‹œìŠ¤í…œ ROI ì¸¡ì • ë° ë¹„ì¦ˆë‹ˆìŠ¤ ê°€ì¹˜ ë¶„ì„
- [ ] ì§€ì†ì  ê°œì„  ë° ìë™í™” ì‹œìŠ¤í…œ êµ¬ì¶•
- [ ] íŒ€ ë¦¬ë”© ë° ê¸°ìˆ  ë©˜í† ë§

### ì‹¤ë¬´ í”„ë¡œì íŠ¸ ì¶”ì²œ ìˆœì„œ

1. **ê°œì¸ í”„ë¡œì íŠ¸**: ê°„ë‹¨í•œ ë°ì´í„° ETL ë°°ì¹˜
2. **íŒ€ í”„ë¡œì íŠ¸**: íšŒì‚¬ ë‚´ë¶€ ë°ì´í„° ì²˜ë¦¬ ìë™í™”
3. **ì„œë¹„ìŠ¤ í”„ë¡œì íŠ¸**: ê³ ê° ëŒ€ìƒ ë°°ì¹˜ ê¸°ë°˜ ì„œë¹„ìŠ¤
4. **í”Œë«í¼ í”„ë¡œì íŠ¸**: ë²”ìš© ë°°ì¹˜ í”Œë«í¼ êµ¬ì¶•
5. **ì˜¤í”ˆì†ŒìŠ¤ ê¸°ì—¬**: Spring Batch ìƒíƒœê³„ ê¸°ì—¬

## ğŸ¯ ë§ˆë¬´ë¦¬ ë° ì‹¤ë¬´ ì¡°ì–¸

### ğŸ”‘ í•µì‹¬ ì›ì¹™
1. **ë‹¨ìˆœí•¨ ì¶”êµ¬**: ë³µì¡í•œ ë°°ì¹˜ë³´ë‹¤ëŠ” ì´í•´í•˜ê¸° ì‰¬ìš´ ë°°ì¹˜
2. **ì ì§„ì  ê°œì„ **: ì²˜ìŒë¶€í„° ì™„ë²½í•˜ë ¤ í•˜ì§€ ë§ê³  ë‹¨ê³„ì  ë°œì „
3. **ëª¨ë‹ˆí„°ë§ ìš°ì„ **: ë°°ì¹˜ ìƒíƒœë¥¼ í•­ìƒ íŒŒì•…í•  ìˆ˜ ìˆë„ë¡ êµ¬ì„±
4. **ì—ëŸ¬ ëŒ€ì‘**: ì‹¤íŒ¨ëŠ” ë‹¹ì—°í•œ ê²ƒ, ë³µêµ¬ ê°€ëŠ¥í•œ ì‹œìŠ¤í…œ ì„¤ê³„
5. **ë¬¸ì„œí™”**: ë°°ì¹˜ ë¡œì§ê³¼ ìš´ì˜ ê°€ì´ë“œ í•„ìˆ˜ ì‘ì„±

### ğŸ’¡ ì‹¤ë¬´ ì„±ê³µ íŒ
- **ì‘ê²Œ ì‹œì‘í•˜ê¸°**: í° ë°°ì¹˜ë¥¼ ì—¬ëŸ¬ ê°œì˜ ì‘ì€ ë°°ì¹˜ë¡œ ë¶„í• 
- **í…ŒìŠ¤íŠ¸ í™˜ê²½ êµ¬ì¶•**: í”„ë¡œë•ì…˜ê³¼ ë™ì¼í•œ í…ŒìŠ¤íŠ¸ í™˜ê²½ í•„ìˆ˜
- **ì„±ëŠ¥ ì¸¡ì •**: ì²˜ìŒë¶€í„° ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì²´ê³„ êµ¬ì¶•
- **ì¥ì•  ëŒ€ì‘ ê³„íš**: ë°°ì¹˜ ì‹¤íŒ¨ ì‹œ ëŒ€ì‘ ì ˆì°¨ ë¯¸ë¦¬ ìˆ˜ë¦½
- **ì§€ì†ì  í•™ìŠµ**: Spring Batch ì»¤ë®¤ë‹ˆí‹° ë° ìµœì‹  ë™í–¥ íŒ”ë¡œìš°

---

ğŸ‰ **ì¶•í•˜í•©ë‹ˆë‹¤!** Spring Batchì˜ ëª¨ë“  í•µì‹¬ ê°œë…ê³¼ ì‹¤ë¬´ í™œìš©ë²•ì„ ë§ˆìŠ¤í„°í–ˆìŠµë‹ˆë‹¤. 

ì´ì œ ì—¬ëŸ¬ë¶„ì€ **ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ë°°ì¹˜ ì‹œìŠ¤í…œì„ ì„¤ê³„í•˜ê³  êµ¬í˜„í•  ìˆ˜ ìˆëŠ” ì „ë¬¸ê°€**ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤. 

ì§€ì†ì ì¸ ì‹¤ìŠµê³¼ ì‹¤ë¬´ ì ìš©ì„ í†µí•´ ë”ìš± ë°œì „í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤! ğŸš€