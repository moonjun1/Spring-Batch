# 09. 배치 학습 5단계: 에러 처리, 재시작, 모니터링

## 🎯 학습 목표
- 배치 실행 중 발생하는 다양한 에러 상황 처리
- Skip, Retry, Restart 정책 구현
- 배치 실행 상태 모니터링 및 알림 시스템 구축
- 실무에서 필요한 로깅 및 추적 기능 구현

## 🚨 에러 처리 전략

### 에러 유형별 처리 방법
```
[Reader 에러]           [Processor 에러]        [Writer 에러]
     ↓                      ↓                    ↓
- 파일 없음/읽기 실패       - 데이터 검증 실패       - DB 연결 실패
- 네트워크 연결 실패       - 외부 API 호출 실패     - 제약조건 위반
- 권한 없음              - 메모리 부족           - 트랜잭션 충돌
     ↓                      ↓                    ↓
[재시도] or [건너뛰기]    [건너뛰기] or [중단]    [재시도] or [중단]
```

### 1. 고급 Skip 정책 구현
```java
package com.example.batchtutorial.policy;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.step.skip.SkipLimitExceededException;
import org.springframework.batch.core.step.skip.SkipPolicy;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.web.client.ResourceAccessException;

import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

/**
 * 에러 유형별 차등 Skip 정책
 */
@Slf4j
public class SmartSkipPolicy implements SkipPolicy {
    
    private final Map<Class<? extends Throwable>, Integer> skipLimits;
    private final Map<Class<? extends Throwable>, Integer> currentCounts;
    
    public SmartSkipPolicy() {
        this.skipLimits = new HashMap<>();
        this.currentCounts = new HashMap<>();
        
        // 에러 유형별 Skip 한도 설정
        skipLimits.put(ValidationException.class, 50);              // 검증 오류: 50개까지
        skipLimits.put(DataIntegrityViolationException.class, 10);  // DB 제약조건: 10개까지
        skipLimits.put(ResourceAccessException.class, 5);           // 네트워크 오류: 5개까지
        skipLimits.put(SQLException.class, 3);                      // SQL 오류: 3개까지
    }
    
    @Override
    public boolean shouldSkip(Throwable exception, int skipCount) throws SkipLimitExceededException {
        
        Class<? extends Throwable> exceptionClass = exception.getClass();
        
        // 에러 유형별 카운터 증가
        currentCounts.put(exceptionClass, currentCounts.getOrDefault(exceptionClass, 0) + 1);
        
        // 해당 에러 유형의 Skip 한도 확인
        Integer limit = skipLimits.get(exceptionClass);
        if (limit == null) {
            log.error("Unknown exception type, not skipping: {}", exceptionClass.getSimpleName());
            return false;  // 알 수 없는 에러는 Skip 하지 않음
        }
        
        Integer currentCount = currentCounts.get(exceptionClass);
        
        if (currentCount <= limit) {
            log.warn("Skipping exception #{} of type {}: {} (limit: {})", 
                    currentCount, exceptionClass.getSimpleName(), exception.getMessage(), limit);
            return true;
        } else {
            log.error("Skip limit exceeded for {}: {} > {}", 
                    exceptionClass.getSimpleName(), currentCount, limit);
            throw new SkipLimitExceededException(limit, exception);
        }
    }
    
    /**
     * Skip 통계 정보 반환
     */
    public Map<String, Integer> getSkipStatistics() {
        Map<String, Integer> stats = new HashMap<>();
        currentCounts.forEach((clazz, count) -> 
            stats.put(clazz.getSimpleName(), count)
        );
        return stats;
    }
}
```

### 2. 지능적 Retry 정책 구현
```java
package com.example.batchtutorial.policy;

import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.TransientDataAccessException;
import org.springframework.retry.RetryContext;
import org.springframework.retry.policy.RetryPolicy;
import org.springframework.web.client.ResourceAccessException;

import java.net.ConnectException;
import java.net.SocketTimeoutException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * 에러 유형별 차등 Retry 정책
 */
@Slf4j
public class SmartRetryPolicy implements RetryPolicy {
    
    private final Map<Class<? extends Throwable>, Integer> retryLimits;
    private final Map<Class<? extends Throwable>, Duration> backoffIntervals;
    
    public SmartRetryPolicy() {
        this.retryLimits = new HashMap<>();
        this.backoffIntervals = new HashMap<>();
        
        // 에러 유형별 재시도 설정
        retryLimits.put(ConnectException.class, 5);                    // 연결 오류: 5회
        retryLimits.put(SocketTimeoutException.class, 3);              // 타임아웃: 3회
        retryLimits.put(ResourceAccessException.class, 4);             // 리소스 접근: 4회
        retryLimits.put(TransientDataAccessException.class, 3);        // DB 일시 오류: 3회
        
        // 백오프 간격 설정
        backoffIntervals.put(ConnectException.class, Duration.ofSeconds(2));
        backoffIntervals.put(SocketTimeoutException.class, Duration.ofSeconds(5));
        backoffIntervals.put(ResourceAccessException.class, Duration.ofSeconds(3));
        backoffIntervals.put(TransientDataAccessException.class, Duration.ofSeconds(1));
    }
    
    @Override
    public boolean canRetry(RetryContext context) {
        Throwable lastThrowable = context.getLastThrowable();
        if (lastThrowable == null) {
            return true;
        }
        
        Class<? extends Throwable> exceptionClass = lastThrowable.getClass();
        Integer limit = retryLimits.get(exceptionClass);
        
        if (limit == null) {
            log.debug("No retry policy for exception type: {}", exceptionClass.getSimpleName());
            return false;  // 재시도 정책이 없는 에러는 재시도 안함
        }
        
        int attemptCount = context.getRetryCount();
        boolean canRetry = attemptCount < limit;
        
        if (canRetry) {
            Duration backoff = backoffIntervals.get(exceptionClass);
            if (backoff != null && attemptCount > 0) {
                log.info("Retrying in {} seconds... (attempt {} of {})", 
                        backoff.getSeconds(), attemptCount + 1, limit);
                
                try {
                    Thread.sleep(backoff.toMillis());
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
            
            log.warn("Retrying operation (attempt {} of {}) for error: {}", 
                    attemptCount + 1, limit, lastThrowable.getMessage());
        } else {
            log.error("Retry limit exceeded for {}: {} attempts", 
                    exceptionClass.getSimpleName(), limit);
        }
        
        return canRetry;
    }
    
    @Override
    public RetryContext open(RetryContext parent) {
        return new RetryContext() {
            private int count = 0;
            private Throwable lastThrowable;
            private final LocalDateTime startTime = LocalDateTime.now();
            
            @Override
            public boolean isExhaustedOnly() {
                return false;
            }
            
            @Override
            public Throwable getLastThrowable() {
                return lastThrowable;
            }
            
            @Override
            public int getRetryCount() {
                return count;
            }
            
            @Override
            public void registerThrowable(Throwable throwable) {
                this.lastThrowable = throwable;
                this.count++;
            }
            
            @Override
            public void setAttribute(String name, Object value) {
                // 필요한 경우 속성 저장 구현
            }
            
            @Override
            public Object getAttribute(String name) {
                return null;
            }
        };
    }
    
    @Override
    public void close(RetryContext context) {
        if (context.getRetryCount() > 0) {
            log.info("Retry operation completed after {} attempts", context.getRetryCount());
        }
    }
}
```

### 3. 포괄적 에러 처리 Step 설정
```java
package com.example.batchtutorial.config;

import com.example.batchtutorial.exception.ValidationException;
import com.example.batchtutorial.policy.SmartRetryPolicy;
import com.example.batchtutorial.policy.SmartSkipPolicy;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.dao.TransientDataAccessException;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.web.client.ResourceAccessException;

import java.net.ConnectException;
import java.net.SocketTimeoutException;

/**
 * 포괄적 에러 처리가 적용된 배치 설정
 */
@Slf4j
@Configuration
public class ErrorHandlingBatchConfig {
    
    @Autowired
    private JobRepository jobRepository;
    
    @Autowired
    private PlatformTransactionManager transactionManager;
    
    /**
     * 에러 처리가 강화된 Job
     */
    @Bean
    public Job resilientJob(Step resilientStep) {
        return new JobBuilder("resilientJob", jobRepository)
                .start(resilientStep)
                .build();
    }
    
    /**
     * 포괄적 에러 처리 Step
     */
    @Bean
    public Step resilientStep(ItemReader<Object> reader,
                             ItemProcessor<Object, Object> processor,
                             ItemWriter<Object> writer) {
        return new StepBuilder("resilientStep", jobRepository)
                .<Object, Object>chunk(50, transactionManager)
                .reader(reader)
                .processor(processor)
                .writer(writer)
                
                // Fault Tolerance 활성화
                .faultTolerant()
                
                // Skip 정책 설정
                .skipPolicy(new SmartSkipPolicy())
                .skip(ValidationException.class)
                .skip(DataIntegrityViolationException.class)
                .skip(ResourceAccessException.class)
                
                // Retry 정책 설정
                .retryPolicy(new SmartRetryPolicy())
                .retry(ConnectException.class)
                .retry(SocketTimeoutException.class)
                .retry(TransientDataAccessException.class)
                
                // 치명적 예외 (Skip/Retry 하지 않음)
                .noSkip(OutOfMemoryError.class)
                .noSkip(StackOverflowError.class)
                .noRetry(OutOfMemoryError.class)
                
                // 리스너 등록
                .listener(errorHandlingStepListener())
                .listener(new DetailedSkipListener())
                
                build();
    }
    
    @Bean
    public ErrorHandlingStepListener errorHandlingStepListener() {
        return new ErrorHandlingStepListener();
    }
}
```

## 🔄 배치 재시작 기능

### 1. 재시작 가능한 Job 설정
```java
package com.example.batchtutorial.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.job.flow.FlowExecutionStatus;
import org.springframework.batch.core.job.flow.JobExecutionDecider;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.PlatformTransactionManager;

/**
 * 재시작 가능한 배치 Job 설정
 */
@Slf4j
@Configuration
public class RestartableBatchConfig {
    
    @Autowired
    private JobRepository jobRepository;
    
    @Autowired
    private PlatformTransactionManager transactionManager;
    
    /**
     * 재시작 가능한 Job
     */
    @Bean
    public Job restartableJob(Step dataProcessingStep, 
                             Step dataValidationStep,
                             Step dataCleanupStep,
                             JobExecutionDecider restartDecider) {
        return new JobBuilder("restartableJob", jobRepository)
                .start(dataProcessingStep)
                .next(restartDecider)
                .from(restartDecider).on("RESTART_NEEDED").to(dataValidationStep)
                .from(restartDecider).on("CONTINUE").to(dataCleanupStep)
                .build();
    }
    
    /**
     * 데이터 처리 Step (재시작 지점 추적)
     */
    @Bean
    public Step dataProcessingStep(ItemReader<Object> reader,
                                  ItemProcessor<Object, Object> processor,
                                  ItemWriter<Object> writer) {
        return new StepBuilder("dataProcessingStep", jobRepository)
                .<Object, Object>chunk(100, transactionManager)
                .reader(reader)
                .processor(processor)
                .writer(writer)
                
                // 재시작을 위한 상태 저장 활성화
                .allowStartIfComplete(false)  // 완료된 Step은 재시작하지 않음
                
                // 재시작 지점 추적
                .listener(new RestartPointTrackingListener())
                
                build();
    }
    
    /**
     * 재시작 결정자
     */
    @Bean
    public JobExecutionDecider restartDecider() {
        return (jobExecution, stepExecution) -> {
            
            // 이전 실행에서 실패했는지 확인
            if (stepExecution != null && stepExecution.getExitStatus().getExitCode().equals("FAILED")) {
                log.info("Previous execution failed, restart needed");
                return new FlowExecutionStatus("RESTART_NEEDED");
            }
            
            // Step 실행 통계 확인
            if (stepExecution != null && stepExecution.getSkipCount() > 10) {
                log.warn("High skip count detected: {}, validation needed", stepExecution.getSkipCount());
                return new FlowExecutionStatus("RESTART_NEEDED");
            }
            
            return new FlowExecutionStatus("CONTINUE");
        };
    }
}
```

### 2. 재시작 지점 추적 리스너
```java
package com.example.batchtutorial.listener;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.*;
import org.springframework.batch.core.listener.StepExecutionListenerSupport;
import org.springframework.batch.item.ExecutionContext;

import java.time.LocalDateTime;

/**
 * 재시작 지점을 추적하는 리스너
 */
@Slf4j
public class RestartPointTrackingListener extends StepExecutionListenerSupport {
    
    private static final String LAST_PROCESSED_ID = "last.processed.id";
    private static final String RESTART_COUNT = "restart.count";
    private static final String LAST_RESTART_TIME = "last.restart.time";
    
    @Override
    public void beforeStep(StepExecution stepExecution) {
        ExecutionContext executionContext = stepExecution.getExecutionContext();
        
        // 재시작 횟수 증가
        int restartCount = executionContext.getInt(RESTART_COUNT, 0);
        if (stepExecution.getJobExecution().getJobInstance().getVersion() > 0) {
            restartCount++;
            executionContext.putInt(RESTART_COUNT, restartCount);
            executionContext.putString(LAST_RESTART_TIME, LocalDateTime.now().toString());
            
            log.info("🔄 Job restarted {} times. Last restart: {}", 
                    restartCount, LocalDateTime.now());
        }
        
        // 마지막 처리 지점 복원
        Long lastProcessedId = executionContext.getLong(LAST_PROCESSED_ID, 0L);
        if (lastProcessedId > 0) {
            log.info("📍 Resuming from last processed ID: {}", lastProcessedId);
        }
    }
    
    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        ExecutionContext executionContext = stepExecution.getExecutionContext();
        
        // 처리 통계 저장
        executionContext.putLong("final.read.count", stepExecution.getReadCount());
        executionContext.putLong("final.write.count", stepExecution.getWriteCount());
        executionContext.putLong("final.skip.count", stepExecution.getSkipCount());
        
        // 재시작이 필요한 조건 확인
        if (stepExecution.getSkipCount() > 50) {
            log.warn("⚠️ High skip count: {}. Step marked for review", stepExecution.getSkipCount());
            return new ExitStatus("FAILED", "High skip count requires review");
        }
        
        if (stepExecution.getWriteCount() == 0) {
            log.warn("⚠️ No items written. Possible data source issue");
            return new ExitStatus("FAILED", "No data processed");
        }
        
        log.info("✅ Step completed successfully. Read: {}, Write: {}, Skip: {}", 
                stepExecution.getReadCount(), 
                stepExecution.getWriteCount(), 
                stepExecution.getSkipCount());
        
        return stepExecution.getExitStatus();
    }
    
    /**
     * 현재 처리 지점 업데이트 (ItemWriter에서 호출)
     */
    public static void updateLastProcessedId(ExecutionContext context, Long id) {
        context.putLong(LAST_PROCESSED_ID, id);
    }
}
```

## 📊 실시간 배치 모니터링

### 1. 배치 상태 모니터링 서비스
```java
package com.example.batchtutorial.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.*;
import org.springframework.batch.core.explore.JobExplorer;
import org.springframework.batch.core.launch.JobOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;
import java.util.stream.Collectors;

/**
 * 배치 모니터링 서비스
 */
@Slf4j
@Service
public class BatchMonitoringService {
    
    @Autowired
    private JobExplorer jobExplorer;
    
    @Autowired
    private JobOperator jobOperator;
    
    /**
     * 실행 중인 배치 목록 조회
     */
    public List<BatchExecutionInfo> getRunningBatches() {
        List<BatchExecutionInfo> runningBatches = new ArrayList<>();
        
        Set<Long> runningExecutions = jobOperator.getRunningExecutions("*");
        
        for (Long executionId : runningExecutions) {
            JobExecution jobExecution = jobExplorer.getJobExecution(executionId);
            if (jobExecution != null) {
                BatchExecutionInfo info = createBatchInfo(jobExecution);
                runningBatches.add(info);
            }
        }
        
        return runningBatches;
    }
    
    /**
     * 최근 배치 실행 이력 조회
     */
    public List<BatchExecutionInfo> getRecentBatchHistory(int count) {
        List<String> jobNames = jobExplorer.getJobNames();
        List<BatchExecutionInfo> recentExecutions = new ArrayList<>();
        
        for (String jobName : jobNames) {
            List<JobInstance> jobInstances = jobExplorer.getJobInstances(jobName, 0, count);
            
            for (JobInstance instance : jobInstances) {
                List<JobExecution> executions = jobExplorer.getJobExecutions(instance);
                for (JobExecution execution : executions) {
                    BatchExecutionInfo info = createBatchInfo(execution);
                    recentExecutions.add(info);
                }
            }
        }
        
        // 최근 실행 순으로 정렬
        return recentExecutions.stream()
                .sorted((a, b) -> b.getStartTime().compareTo(a.getStartTime()))
                .limit(count)
                .collect(Collectors.toList());
    }
    
    /**
     * 특정 Job의 상세 정보 조회
     */
    public DetailedBatchInfo getBatchDetails(Long executionId) {
        JobExecution jobExecution = jobExplorer.getJobExecution(executionId);
        if (jobExecution == null) {
            return null;
        }
        
        DetailedBatchInfo details = new DetailedBatchInfo();
        details.setJobExecution(jobExecution);
        
        // Step별 상세 정보
        Collection<StepExecution> stepExecutions = jobExecution.getStepExecutions();
        List<StepExecutionInfo> stepInfos = new ArrayList<>();
        
        for (StepExecution stepExecution : stepExecutions) {
            StepExecutionInfo stepInfo = createStepInfo(stepExecution);
            stepInfos.add(stepInfo);
        }
        
        details.setStepExecutions(stepInfos);
        details.setOverallStatistics(calculateOverallStatistics(stepExecutions));
        
        return details;
    }
    
    /**
     * 배치 실행 중단
     */
    public boolean stopBatch(Long executionId) {
        try {
            boolean stopped = jobOperator.stop(executionId);
            if (stopped) {
                log.info("🛑 Batch execution {} stopped successfully", executionId);
            } else {
                log.warn("⚠️ Failed to stop batch execution {}", executionId);
            }
            return stopped;
        } catch (Exception e) {
            log.error("❌ Error stopping batch execution {}: {}", executionId, e.getMessage());
            return false;
        }
    }
    
    /**
     * 배치 재시작
     */
    public Long restartBatch(Long executionId) {
        try {
            Long newExecutionId = jobOperator.restart(executionId);
            log.info("🔄 Batch execution {} restarted as {}", executionId, newExecutionId);
            return newExecutionId;
        } catch (Exception e) {
            log.error("❌ Error restarting batch execution {}: {}", executionId, e.getMessage());
            return null;
        }
    }
    
    /**
     * 시스템 상태 체크
     */
    public SystemHealthInfo getSystemHealth() {
        SystemHealthInfo health = new SystemHealthInfo();
        
        // 메모리 사용량
        Runtime runtime = Runtime.getRuntime();
        long maxMemory = runtime.maxMemory();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        health.setMemoryUsage((double) usedMemory / maxMemory * 100);
        
        // 실행 중인 배치 개수
        health.setRunningBatchCount(getRunningBatches().size());
        
        // 최근 실패한 배치 개수
        List<BatchExecutionInfo> recentBatches = getRecentBatchHistory(50);
        long failedCount = recentBatches.stream()
                .filter(batch -> "FAILED".equals(batch.getStatus()))
                .count();
        health.setRecentFailureCount(failedCount);
        
        // 전체 상태 결정
        if (health.getMemoryUsage() > 90 || failedCount > 5) {
            health.setOverallStatus("CRITICAL");
        } else if (health.getMemoryUsage() > 70 || failedCount > 2) {
            health.setOverallStatus("WARNING");
        } else {
            health.setOverallStatus("HEALTHY");
        }
        
        return health;
    }
    
    // 헬퍼 메서드들
    private BatchExecutionInfo createBatchInfo(JobExecution jobExecution) {
        BatchExecutionInfo info = new BatchExecutionInfo();
        info.setExecutionId(jobExecution.getId());
        info.setJobName(jobExecution.getJobInstance().getJobName());
        info.setStatus(jobExecution.getStatus().toString());
        info.setStartTime(LocalDateTime.ofInstant(jobExecution.getStartTime().toInstant(), ZoneId.systemDefault()));
        
        if (jobExecution.getEndTime() != null) {
            info.setEndTime(LocalDateTime.ofInstant(jobExecution.getEndTime().toInstant(), ZoneId.systemDefault()));
            info.setDuration(Duration.between(info.getStartTime(), info.getEndTime()));
        }
        
        // 진행률 계산
        Collection<StepExecution> stepExecutions = jobExecution.getStepExecutions();
        if (!stepExecutions.isEmpty()) {
            long totalRead = stepExecutions.stream().mapToLong(StepExecution::getReadCount).sum();
            long totalWrite = stepExecutions.stream().mapToLong(StepExecution::getWriteCount).sum();
            
            info.setTotalReadCount(totalRead);
            info.setTotalWriteCount(totalWrite);
            info.setProgress(totalRead > 0 ? (double) totalWrite / totalRead * 100 : 0);
        }
        
        return info;
    }
    
    private StepExecutionInfo createStepInfo(StepExecution stepExecution) {
        StepExecutionInfo info = new StepExecutionInfo();
        info.setStepName(stepExecution.getStepName());
        info.setStatus(stepExecution.getStatus().toString());
        info.setReadCount(stepExecution.getReadCount());
        info.setWriteCount(stepExecution.getWriteCount());
        info.setSkipCount(stepExecution.getSkipCount());
        info.setCommitCount(stepExecution.getCommitCount());
        
        if (stepExecution.getStartTime() != null && stepExecution.getEndTime() != null) {
            LocalDateTime start = LocalDateTime.ofInstant(stepExecution.getStartTime().toInstant(), ZoneId.systemDefault());
            LocalDateTime end = LocalDateTime.ofInstant(stepExecution.getEndTime().toInstant(), ZoneId.systemDefault());
            info.setDuration(Duration.between(start, end));
            
            // 처리 속도 계산
            long durationSeconds = info.getDuration().getSeconds();
            if (durationSeconds > 0) {
                info.setThroughput((double) stepExecution.getWriteCount() / durationSeconds);
            }
        }
        
        return info;
    }
    
    private Map<String, Object> calculateOverallStatistics(Collection<StepExecution> stepExecutions) {
        Map<String, Object> stats = new HashMap<>();
        
        long totalRead = stepExecutions.stream().mapToLong(StepExecution::getReadCount).sum();
        long totalWrite = stepExecutions.stream().mapToLong(StepExecution::getWriteCount).sum();
        long totalSkip = stepExecutions.stream().mapToLong(StepExecution::getSkipCount).sum();
        
        stats.put("totalRead", totalRead);
        stats.put("totalWrite", totalWrite);
        stats.put("totalSkip", totalSkip);
        stats.put("successRate", totalRead > 0 ? (double) totalWrite / totalRead * 100 : 0);
        
        return stats;
    }
}

// 데이터 클래스들
@Data
class BatchExecutionInfo {
    private Long executionId;
    private String jobName;
    private String status;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private Duration duration;
    private Long totalReadCount;
    private Long totalWriteCount;
    private Double progress;
}

@Data
class DetailedBatchInfo {
    private JobExecution jobExecution;
    private List<StepExecutionInfo> stepExecutions;
    private Map<String, Object> overallStatistics;
}

@Data
class StepExecutionInfo {
    private String stepName;
    private String status;
    private int readCount;
    private int writeCount;
    private int skipCount;
    private int commitCount;
    private Duration duration;
    private Double throughput;
}

@Data
class SystemHealthInfo {
    private String overallStatus;
    private Double memoryUsage;
    private Integer runningBatchCount;
    private Long recentFailureCount;
    private LocalDateTime checkedAt = LocalDateTime.now();
}
```

### 2. 배치 모니터링 REST API
```java
package com.example.batchtutorial.controller;

import com.example.batchtutorial.service.BatchMonitoringService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

/**
 * 배치 모니터링 REST API
 */
@Slf4j
@RestController
@RequestMapping("/api/batch")
public class BatchMonitoringController {
    
    @Autowired
    private BatchMonitoringService monitoringService;
    
    /**
     * 실행 중인 배치 목록
     */
    @GetMapping("/running")
    public List<BatchExecutionInfo> getRunningBatches() {
        return monitoringService.getRunningBatches();
    }
    
    /**
     * 최근 배치 실행 이력
     */
    @GetMapping("/history")
    public List<BatchExecutionInfo> getBatchHistory(
            @RequestParam(defaultValue = "20") int count) {
        return monitoringService.getRecentBatchHistory(count);
    }
    
    /**
     * 특정 배치 상세 정보
     */
    @GetMapping("/{executionId}")
    public ResponseEntity<DetailedBatchInfo> getBatchDetails(@PathVariable Long executionId) {
        DetailedBatchInfo details = monitoringService.getBatchDetails(executionId);
        if (details != null) {
            return ResponseEntity.ok(details);
        } else {
            return ResponseEntity.notFound().build();
        }
    }
    
    /**
     * 배치 중단
     */
    @PostMapping("/{executionId}/stop")
    public ResponseEntity<Map<String, Object>> stopBatch(@PathVariable Long executionId) {
        boolean stopped = monitoringService.stopBatch(executionId);
        return ResponseEntity.ok(Map.of(
            "success", stopped,
            "message", stopped ? "Batch stopped successfully" : "Failed to stop batch"
        ));
    }
    
    /**
     * 배치 재시작
     */
    @PostMapping("/{executionId}/restart")
    public ResponseEntity<Map<String, Object>> restartBatch(@PathVariable Long executionId) {
        Long newExecutionId = monitoringService.restartBatch(executionId);
        if (newExecutionId != null) {
            return ResponseEntity.ok(Map.of(
                "success", true,
                "newExecutionId", newExecutionId,
                "message", "Batch restarted successfully"
            ));
        } else {
            return ResponseEntity.ok(Map.of(
                "success", false,
                "message", "Failed to restart batch"
            ));
        }
    }
    
    /**
     * 시스템 상태 체크
     */
    @GetMapping("/health")
    public SystemHealthInfo getSystemHealth() {
        return monitoringService.getSystemHealth();
    }
    
    /**
     * 배치 통계 대시보드
     */
    @GetMapping("/dashboard")
    public Map<String, Object> getDashboardData() {
        List<BatchExecutionInfo> runningBatches = monitoringService.getRunningBatches();
        List<BatchExecutionInfo> recentHistory = monitoringService.getRecentBatchHistory(100);
        SystemHealthInfo health = monitoringService.getSystemHealth();
        
        // 성공률 계산
        long totalBatches = recentHistory.size();
        long successfulBatches = recentHistory.stream()
                .filter(batch -> "COMPLETED".equals(batch.getStatus()))
                .count();
        
        double successRate = totalBatches > 0 ? (double) successfulBatches / totalBatches * 100 : 0;
        
        return Map.of(
            "runningBatches", runningBatches,
            "recentHistory", recentHistory.stream().limit(10).toList(),
            "systemHealth", health,
            "statistics", Map.of(
                "totalBatches", totalBatches,
                "successfulBatches", successfulBatches,
                "successRate", successRate
            )
        );
    }
}
```

### 3. 실시간 알림 시스템
```java
package com.example.batchtutorial.notification;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.batch.core.StepExecution;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.ZoneId;

/**
 * 배치 실행 결과에 따른 알림 발송
 */
@Slf4j
@Component
public class BatchNotificationService implements JobExecutionListener {
    
    @Value("${batch.notification.email.enabled:true}")
    private boolean emailNotificationEnabled;
    
    @Value("${batch.notification.slack.enabled:false}")
    private boolean slackNotificationEnabled;
    
    @Value("${batch.notification.threshold.duration:300}")  // 5분
    private long longRunningThresholdSeconds;
    
    @Override
    public void beforeJob(JobExecution jobExecution) {
        String jobName = jobExecution.getJobInstance().getJobName();
        log.info("📧 Job started notification: {}", jobName);
        
        if (emailNotificationEnabled) {
            sendJobStartNotification(jobName);
        }
    }
    
    @Override
    public void afterJob(JobExecution jobExecution) {
        String jobName = jobExecution.getJobInstance().getJobName();
        String status = jobExecution.getExitStatus().getExitCode();
        
        LocalDateTime startTime = LocalDateTime.ofInstant(
                jobExecution.getStartTime().toInstant(), ZoneId.systemDefault());
        LocalDateTime endTime = LocalDateTime.ofInstant(
                jobExecution.getEndTime().toInstant(), ZoneId.systemDefault());
        Duration duration = Duration.between(startTime, endTime);
        
        // 실행 통계 수집
        JobExecutionSummary summary = createExecutionSummary(jobExecution, duration);
        
        // 상태에 따른 알림 발송
        switch (status) {
            case "COMPLETED" -> handleSuccessfulCompletion(summary);
            case "FAILED" -> handleFailure(summary);
            case "STOPPED" -> handleStopped(summary);
            default -> handleUnknownStatus(summary);
        }
        
        // 장시간 실행 알림
        if (duration.getSeconds() > longRunningThresholdSeconds) {
            sendLongRunningJobAlert(summary);
        }
    }
    
    private void handleSuccessfulCompletion(JobExecutionSummary summary) {
        log.info("✅ Job completed successfully: {}", summary.getJobName());
        
        if (emailNotificationEnabled) {
            sendSuccessNotification(summary);
        }
        
        if (slackNotificationEnabled) {
            sendSlackSuccessMessage(summary);
        }
    }
    
    private void handleFailure(JobExecutionSummary summary) {
        log.error("❌ Job failed: {}", summary.getJobName());
        
        // 실패 시 항상 알림 발송
        sendFailureNotification(summary);
        
        if (slackNotificationEnabled) {
            sendSlackFailureAlert(summary);
        }
        
        // 긴급 알림 (SMS, 전화 등) - 실제 구현 필요
        if (summary.isCritical()) {
            sendUrgentAlert(summary);
        }
    }
    
    private void handleStopped(JobExecutionSummary summary) {
        log.warn("🛑 Job was stopped: {}", summary.getJobName());
        sendJobStoppedNotification(summary);
    }
    
    private JobExecutionSummary createExecutionSummary(JobExecution jobExecution, Duration duration) {
        JobExecutionSummary summary = new JobExecutionSummary();
        summary.setJobName(jobExecution.getJobInstance().getJobName());
        summary.setExecutionId(jobExecution.getId());
        summary.setStatus(jobExecution.getExitStatus().getExitCode());
        summary.setDuration(duration);
        summary.setStartTime(LocalDateTime.ofInstant(
                jobExecution.getStartTime().toInstant(), ZoneId.systemDefault()));
        summary.setEndTime(LocalDateTime.ofInstant(
                jobExecution.getEndTime().toInstant(), ZoneId.systemDefault()));
        
        // Step 통계 수집
        long totalRead = 0, totalWrite = 0, totalSkip = 0;
        StringBuilder stepDetails = new StringBuilder();
        
        for (StepExecution step : jobExecution.getStepExecutions()) {
            totalRead += step.getReadCount();
            totalWrite += step.getWriteCount();
            totalSkip += step.getSkipCount();
            
            stepDetails.append(String.format(
                "- %s: Read=%d, Write=%d, Skip=%d%n", 
                step.getStepName(), step.getReadCount(), step.getWriteCount(), step.getSkipCount()
            ));
        }
        
        summary.setTotalRead(totalRead);
        summary.setTotalWrite(totalWrite);
        summary.setTotalSkip(totalSkip);
        summary.setStepDetails(stepDetails.toString());
        
        // 중요도 판단
        summary.setCritical(jobExecution.getJobInstance().getJobName().contains("CRITICAL") || 
                           totalSkip > 1000 || 
                           duration.getSeconds() > 3600); // 1시간 이상
        
        return summary;
    }
    
    private void sendSuccessNotification(JobExecutionSummary summary) {
        String subject = String.format("✅ Batch Job Completed: %s", summary.getJobName());
        String body = String.format("""
            Job: %s
            Status: COMPLETED
            Duration: %d minutes
            
            Statistics:
            - Read: %,d items
            - Write: %,d items
            - Skip: %,d items
            - Success Rate: %.2f%%
            
            Step Details:
            %s
            """, 
            summary.getJobName(),
            summary.getDuration().toMinutes(),
            summary.getTotalRead(),
            summary.getTotalWrite(),
            summary.getTotalSkip(),
            summary.getTotalRead() > 0 ? (double) summary.getTotalWrite() / summary.getTotalRead() * 100 : 0,
            summary.getStepDetails()
        );
        
        sendEmailNotification(subject, body);
    }
    
    private void sendFailureNotification(JobExecutionSummary summary) {
        String subject = String.format("❌ Batch Job FAILED: %s", summary.getJobName());
        String body = String.format("""
            🚨 BATCH JOB FAILURE ALERT 🚨
            
            Job: %s
            Status: FAILED
            Execution ID: %d
            Duration: %d minutes
            
            Failure occurred at: %s
            
            Statistics:
            - Read: %,d items
            - Write: %,d items  
            - Skip: %,d items
            
            Step Details:
            %s
            
            Please check the logs and take appropriate action.
            """,
            summary.getJobName(),
            summary.getExecutionId(),
            summary.getDuration().toMinutes(),
            summary.getEndTime(),
            summary.getTotalRead(),
            summary.getTotalWrite(),
            summary.getTotalSkip(),
            summary.getStepDetails()
        );
        
        sendEmailNotification(subject, body);
    }
    
    private void sendEmailNotification(String subject, String body) {
        // 실제 이메일 발송 구현
        log.info("📧 EMAIL NOTIFICATION: {}", subject);
        log.debug("Email body: {}", body);
        
        // JavaMailSender 등을 사용한 실제 이메일 발송 로직 구현
        // emailService.sendNotification(subject, body);
    }
    
    private void sendSlackSuccessMessage(JobExecutionSummary summary) {
        String message = String.format(
            "✅ Batch job `%s` completed successfully in %d minutes. Processed %,d items.",
            summary.getJobName(), summary.getDuration().toMinutes(), summary.getTotalWrite()
        );
        
        sendSlackMessage(message, "good");
    }
    
    private void sendSlackFailureAlert(JobExecutionSummary summary) {
        String message = String.format(
            "🚨 Batch job `%s` FAILED after %d minutes. Execution ID: %d. Please check immediately!",
            summary.getJobName(), summary.getDuration().toMinutes(), summary.getExecutionId()
        );
        
        sendSlackMessage(message, "danger");
    }
    
    private void sendSlackMessage(String message, String color) {
        // 실제 Slack API 호출 구현
        log.info("📱 SLACK NOTIFICATION ({}): {}", color, message);
        
        // Slack WebClient를 사용한 메시지 발송 로직 구현
        // slackService.sendMessage(message, color);
    }
    
    // 기타 알림 메서드들...
    private void sendJobStartNotification(String jobName) { /* 구현 */ }
    private void handleUnknownStatus(JobExecutionSummary summary) { /* 구현 */ }
    private void sendLongRunningJobAlert(JobExecutionSummary summary) { /* 구현 */ }
    private void sendJobStoppedNotification(JobExecutionSummary summary) { /* 구현 */ }
    private void sendUrgentAlert(JobExecutionSummary summary) { /* 구현 */ }
}

@Data
class JobExecutionSummary {
    private String jobName;
    private Long executionId;
    private String status;
    private Duration duration;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private long totalRead;
    private long totalWrite;
    private long totalSkip;
    private String stepDetails;
    private boolean critical;
}
```

이제 프로덕션 환경에서 안정적으로 운영할 수 있는 완전한 에러 처리, 재시작, 모니터링 시스템이 구축되었습니다! 마지막 단계에서는 Spring Batch의 고급 활용법과 실무 팁을 학습하겠습니다.