# 09. ë°°ì¹˜ í•™ìŠµ 5ë‹¨ê³„: ì—ëŸ¬ ì²˜ë¦¬, ì¬ì‹œì‘, ëª¨ë‹ˆí„°ë§

## ğŸ¯ í•™ìŠµ ëª©í‘œ
- ë°°ì¹˜ ì‹¤í–‰ ì¤‘ ë°œìƒí•˜ëŠ” ë‹¤ì–‘í•œ ì—ëŸ¬ ìƒí™© ì²˜ë¦¬
- Skip, Retry, Restart ì •ì±… êµ¬í˜„
- ë°°ì¹˜ ì‹¤í–‰ ìƒíƒœ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ êµ¬ì¶•
- ì‹¤ë¬´ì—ì„œ í•„ìš”í•œ ë¡œê¹… ë° ì¶”ì  ê¸°ëŠ¥ êµ¬í˜„

## ğŸš¨ ì—ëŸ¬ ì²˜ë¦¬ ì „ëµ

### ì—ëŸ¬ ìœ í˜•ë³„ ì²˜ë¦¬ ë°©ë²•
```
[Reader ì—ëŸ¬]           [Processor ì—ëŸ¬]        [Writer ì—ëŸ¬]
     â†“                      â†“                    â†“
- íŒŒì¼ ì—†ìŒ/ì½ê¸° ì‹¤íŒ¨       - ë°ì´í„° ê²€ì¦ ì‹¤íŒ¨       - DB ì—°ê²° ì‹¤íŒ¨
- ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì‹¤íŒ¨       - ì™¸ë¶€ API í˜¸ì¶œ ì‹¤íŒ¨     - ì œì•½ì¡°ê±´ ìœ„ë°˜
- ê¶Œí•œ ì—†ìŒ              - ë©”ëª¨ë¦¬ ë¶€ì¡±           - íŠ¸ëœì­ì…˜ ì¶©ëŒ
     â†“                      â†“                    â†“
[ì¬ì‹œë„] or [ê±´ë„ˆë›°ê¸°]    [ê±´ë„ˆë›°ê¸°] or [ì¤‘ë‹¨]    [ì¬ì‹œë„] or [ì¤‘ë‹¨]
```

### 1. ê³ ê¸‰ Skip ì •ì±… êµ¬í˜„
```java
package com.example.batchtutorial.policy;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.step.skip.SkipLimitExceededException;
import org.springframework.batch.core.step.skip.SkipPolicy;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.web.client.ResourceAccessException;

import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

/**
 * ì—ëŸ¬ ìœ í˜•ë³„ ì°¨ë“± Skip ì •ì±…
 */
@Slf4j
public class SmartSkipPolicy implements SkipPolicy {
    
    private final Map<Class<? extends Throwable>, Integer> skipLimits;
    private final Map<Class<? extends Throwable>, Integer> currentCounts;
    
    public SmartSkipPolicy() {
        this.skipLimits = new HashMap<>();
        this.currentCounts = new HashMap<>();
        
        // ì—ëŸ¬ ìœ í˜•ë³„ Skip í•œë„ ì„¤ì •
        skipLimits.put(ValidationException.class, 50);              // ê²€ì¦ ì˜¤ë¥˜: 50ê°œê¹Œì§€
        skipLimits.put(DataIntegrityViolationException.class, 10);  // DB ì œì•½ì¡°ê±´: 10ê°œê¹Œì§€
        skipLimits.put(ResourceAccessException.class, 5);           // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: 5ê°œê¹Œì§€
        skipLimits.put(SQLException.class, 3);                      // SQL ì˜¤ë¥˜: 3ê°œê¹Œì§€
    }
    
    @Override
    public boolean shouldSkip(Throwable exception, int skipCount) throws SkipLimitExceededException {
        
        Class<? extends Throwable> exceptionClass = exception.getClass();
        
        // ì—ëŸ¬ ìœ í˜•ë³„ ì¹´ìš´í„° ì¦ê°€
        currentCounts.put(exceptionClass, currentCounts.getOrDefault(exceptionClass, 0) + 1);
        
        // í•´ë‹¹ ì—ëŸ¬ ìœ í˜•ì˜ Skip í•œë„ í™•ì¸
        Integer limit = skipLimits.get(exceptionClass);
        if (limit == null) {
            log.error("Unknown exception type, not skipping: {}", exceptionClass.getSimpleName());
            return false;  // ì•Œ ìˆ˜ ì—†ëŠ” ì—ëŸ¬ëŠ” Skip í•˜ì§€ ì•ŠìŒ
        }
        
        Integer currentCount = currentCounts.get(exceptionClass);
        
        if (currentCount <= limit) {
            log.warn("Skipping exception #{} of type {}: {} (limit: {})", 
                    currentCount, exceptionClass.getSimpleName(), exception.getMessage(), limit);
            return true;
        } else {
            log.error("Skip limit exceeded for {}: {} > {}", 
                    exceptionClass.getSimpleName(), currentCount, limit);
            throw new SkipLimitExceededException(limit, exception);
        }
    }
    
    /**
     * Skip í†µê³„ ì •ë³´ ë°˜í™˜
     */
    public Map<String, Integer> getSkipStatistics() {
        Map<String, Integer> stats = new HashMap<>();
        currentCounts.forEach((clazz, count) -> 
            stats.put(clazz.getSimpleName(), count)
        );
        return stats;
    }
}
```

### 2. ì§€ëŠ¥ì  Retry ì •ì±… êµ¬í˜„
```java
package com.example.batchtutorial.policy;

import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.TransientDataAccessException;
import org.springframework.retry.RetryContext;
import org.springframework.retry.policy.RetryPolicy;
import org.springframework.web.client.ResourceAccessException;

import java.net.ConnectException;
import java.net.SocketTimeoutException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * ì—ëŸ¬ ìœ í˜•ë³„ ì°¨ë“± Retry ì •ì±…
 */
@Slf4j
public class SmartRetryPolicy implements RetryPolicy {
    
    private final Map<Class<? extends Throwable>, Integer> retryLimits;
    private final Map<Class<? extends Throwable>, Duration> backoffIntervals;
    
    public SmartRetryPolicy() {
        this.retryLimits = new HashMap<>();
        this.backoffIntervals = new HashMap<>();
        
        // ì—ëŸ¬ ìœ í˜•ë³„ ì¬ì‹œë„ ì„¤ì •
        retryLimits.put(ConnectException.class, 5);                    // ì—°ê²° ì˜¤ë¥˜: 5íšŒ
        retryLimits.put(SocketTimeoutException.class, 3);              // íƒ€ì„ì•„ì›ƒ: 3íšŒ
        retryLimits.put(ResourceAccessException.class, 4);             // ë¦¬ì†ŒìŠ¤ ì ‘ê·¼: 4íšŒ
        retryLimits.put(TransientDataAccessException.class, 3);        // DB ì¼ì‹œ ì˜¤ë¥˜: 3íšŒ
        
        // ë°±ì˜¤í”„ ê°„ê²© ì„¤ì •
        backoffIntervals.put(ConnectException.class, Duration.ofSeconds(2));
        backoffIntervals.put(SocketTimeoutException.class, Duration.ofSeconds(5));
        backoffIntervals.put(ResourceAccessException.class, Duration.ofSeconds(3));
        backoffIntervals.put(TransientDataAccessException.class, Duration.ofSeconds(1));
    }
    
    @Override
    public boolean canRetry(RetryContext context) {
        Throwable lastThrowable = context.getLastThrowable();
        if (lastThrowable == null) {
            return true;
        }
        
        Class<? extends Throwable> exceptionClass = lastThrowable.getClass();
        Integer limit = retryLimits.get(exceptionClass);
        
        if (limit == null) {
            log.debug("No retry policy for exception type: {}", exceptionClass.getSimpleName());
            return false;  // ì¬ì‹œë„ ì •ì±…ì´ ì—†ëŠ” ì—ëŸ¬ëŠ” ì¬ì‹œë„ ì•ˆí•¨
        }
        
        int attemptCount = context.getRetryCount();
        boolean canRetry = attemptCount < limit;
        
        if (canRetry) {
            Duration backoff = backoffIntervals.get(exceptionClass);
            if (backoff != null && attemptCount > 0) {
                log.info("Retrying in {} seconds... (attempt {} of {})", 
                        backoff.getSeconds(), attemptCount + 1, limit);
                
                try {
                    Thread.sleep(backoff.toMillis());
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
            
            log.warn("Retrying operation (attempt {} of {}) for error: {}", 
                    attemptCount + 1, limit, lastThrowable.getMessage());
        } else {
            log.error("Retry limit exceeded for {}: {} attempts", 
                    exceptionClass.getSimpleName(), limit);
        }
        
        return canRetry;
    }
    
    @Override
    public RetryContext open(RetryContext parent) {
        return new RetryContext() {
            private int count = 0;
            private Throwable lastThrowable;
            private final LocalDateTime startTime = LocalDateTime.now();
            
            @Override
            public boolean isExhaustedOnly() {
                return false;
            }
            
            @Override
            public Throwable getLastThrowable() {
                return lastThrowable;
            }
            
            @Override
            public int getRetryCount() {
                return count;
            }
            
            @Override
            public void registerThrowable(Throwable throwable) {
                this.lastThrowable = throwable;
                this.count++;
            }
            
            @Override
            public void setAttribute(String name, Object value) {
                // í•„ìš”í•œ ê²½ìš° ì†ì„± ì €ì¥ êµ¬í˜„
            }
            
            @Override
            public Object getAttribute(String name) {
                return null;
            }
        };
    }
    
    @Override
    public void close(RetryContext context) {
        if (context.getRetryCount() > 0) {
            log.info("Retry operation completed after {} attempts", context.getRetryCount());
        }
    }
}
```

### 3. í¬ê´„ì  ì—ëŸ¬ ì²˜ë¦¬ Step ì„¤ì •
```java
package com.example.batchtutorial.config;

import com.example.batchtutorial.exception.ValidationException;
import com.example.batchtutorial.policy.SmartRetryPolicy;
import com.example.batchtutorial.policy.SmartSkipPolicy;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.dao.TransientDataAccessException;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.web.client.ResourceAccessException;

import java.net.ConnectException;
import java.net.SocketTimeoutException;

/**
 * í¬ê´„ì  ì—ëŸ¬ ì²˜ë¦¬ê°€ ì ìš©ëœ ë°°ì¹˜ ì„¤ì •
 */
@Slf4j
@Configuration
public class ErrorHandlingBatchConfig {
    
    @Autowired
    private JobRepository jobRepository;
    
    @Autowired
    private PlatformTransactionManager transactionManager;
    
    /**
     * ì—ëŸ¬ ì²˜ë¦¬ê°€ ê°•í™”ëœ Job
     */
    @Bean
    public Job resilientJob(Step resilientStep) {
        return new JobBuilder("resilientJob", jobRepository)
                .start(resilientStep)
                .build();
    }
    
    /**
     * í¬ê´„ì  ì—ëŸ¬ ì²˜ë¦¬ Step
     */
    @Bean
    public Step resilientStep(ItemReader<Object> reader,
                             ItemProcessor<Object, Object> processor,
                             ItemWriter<Object> writer) {
        return new StepBuilder("resilientStep", jobRepository)
                .<Object, Object>chunk(50, transactionManager)
                .reader(reader)
                .processor(processor)
                .writer(writer)
                
                // Fault Tolerance í™œì„±í™”
                .faultTolerant()
                
                // Skip ì •ì±… ì„¤ì •
                .skipPolicy(new SmartSkipPolicy())
                .skip(ValidationException.class)
                .skip(DataIntegrityViolationException.class)
                .skip(ResourceAccessException.class)
                
                // Retry ì •ì±… ì„¤ì •
                .retryPolicy(new SmartRetryPolicy())
                .retry(ConnectException.class)
                .retry(SocketTimeoutException.class)
                .retry(TransientDataAccessException.class)
                
                // ì¹˜ëª…ì  ì˜ˆì™¸ (Skip/Retry í•˜ì§€ ì•ŠìŒ)
                .noSkip(OutOfMemoryError.class)
                .noSkip(StackOverflowError.class)
                .noRetry(OutOfMemoryError.class)
                
                // ë¦¬ìŠ¤ë„ˆ ë“±ë¡
                .listener(errorHandlingStepListener())
                .listener(new DetailedSkipListener())
                
                build();
    }
    
    @Bean
    public ErrorHandlingStepListener errorHandlingStepListener() {
        return new ErrorHandlingStepListener();
    }
}
```

## ğŸ”„ ë°°ì¹˜ ì¬ì‹œì‘ ê¸°ëŠ¥

### 1. ì¬ì‹œì‘ ê°€ëŠ¥í•œ Job ì„¤ì •
```java
package com.example.batchtutorial.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.job.flow.FlowExecutionStatus;
import org.springframework.batch.core.job.flow.JobExecutionDecider;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.PlatformTransactionManager;

/**
 * ì¬ì‹œì‘ ê°€ëŠ¥í•œ ë°°ì¹˜ Job ì„¤ì •
 */
@Slf4j
@Configuration
public class RestartableBatchConfig {
    
    @Autowired
    private JobRepository jobRepository;
    
    @Autowired
    private PlatformTransactionManager transactionManager;
    
    /**
     * ì¬ì‹œì‘ ê°€ëŠ¥í•œ Job
     */
    @Bean
    public Job restartableJob(Step dataProcessingStep, 
                             Step dataValidationStep,
                             Step dataCleanupStep,
                             JobExecutionDecider restartDecider) {
        return new JobBuilder("restartableJob", jobRepository)
                .start(dataProcessingStep)
                .next(restartDecider)
                .from(restartDecider).on("RESTART_NEEDED").to(dataValidationStep)
                .from(restartDecider).on("CONTINUE").to(dataCleanupStep)
                .build();
    }
    
    /**
     * ë°ì´í„° ì²˜ë¦¬ Step (ì¬ì‹œì‘ ì§€ì  ì¶”ì )
     */
    @Bean
    public Step dataProcessingStep(ItemReader<Object> reader,
                                  ItemProcessor<Object, Object> processor,
                                  ItemWriter<Object> writer) {
        return new StepBuilder("dataProcessingStep", jobRepository)
                .<Object, Object>chunk(100, transactionManager)
                .reader(reader)
                .processor(processor)
                .writer(writer)
                
                // ì¬ì‹œì‘ì„ ìœ„í•œ ìƒíƒœ ì €ì¥ í™œì„±í™”
                .allowStartIfComplete(false)  // ì™„ë£Œëœ Stepì€ ì¬ì‹œì‘í•˜ì§€ ì•ŠìŒ
                
                // ì¬ì‹œì‘ ì§€ì  ì¶”ì 
                .listener(new RestartPointTrackingListener())
                
                build();
    }
    
    /**
     * ì¬ì‹œì‘ ê²°ì •ì
     */
    @Bean
    public JobExecutionDecider restartDecider() {
        return (jobExecution, stepExecution) -> {
            
            // ì´ì „ ì‹¤í–‰ì—ì„œ ì‹¤íŒ¨í–ˆëŠ”ì§€ í™•ì¸
            if (stepExecution != null && stepExecution.getExitStatus().getExitCode().equals("FAILED")) {
                log.info("Previous execution failed, restart needed");
                return new FlowExecutionStatus("RESTART_NEEDED");
            }
            
            // Step ì‹¤í–‰ í†µê³„ í™•ì¸
            if (stepExecution != null && stepExecution.getSkipCount() > 10) {
                log.warn("High skip count detected: {}, validation needed", stepExecution.getSkipCount());
                return new FlowExecutionStatus("RESTART_NEEDED");
            }
            
            return new FlowExecutionStatus("CONTINUE");
        };
    }
}
```

### 2. ì¬ì‹œì‘ ì§€ì  ì¶”ì  ë¦¬ìŠ¤ë„ˆ
```java
package com.example.batchtutorial.listener;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.*;
import org.springframework.batch.core.listener.StepExecutionListenerSupport;
import org.springframework.batch.item.ExecutionContext;

import java.time.LocalDateTime;

/**
 * ì¬ì‹œì‘ ì§€ì ì„ ì¶”ì í•˜ëŠ” ë¦¬ìŠ¤ë„ˆ
 */
@Slf4j
public class RestartPointTrackingListener extends StepExecutionListenerSupport {
    
    private static final String LAST_PROCESSED_ID = "last.processed.id";
    private static final String RESTART_COUNT = "restart.count";
    private static final String LAST_RESTART_TIME = "last.restart.time";
    
    @Override
    public void beforeStep(StepExecution stepExecution) {
        ExecutionContext executionContext = stepExecution.getExecutionContext();
        
        // ì¬ì‹œì‘ íšŸìˆ˜ ì¦ê°€
        int restartCount = executionContext.getInt(RESTART_COUNT, 0);
        if (stepExecution.getJobExecution().getJobInstance().getVersion() > 0) {
            restartCount++;
            executionContext.putInt(RESTART_COUNT, restartCount);
            executionContext.putString(LAST_RESTART_TIME, LocalDateTime.now().toString());
            
            log.info("ğŸ”„ Job restarted {} times. Last restart: {}", 
                    restartCount, LocalDateTime.now());
        }
        
        // ë§ˆì§€ë§‰ ì²˜ë¦¬ ì§€ì  ë³µì›
        Long lastProcessedId = executionContext.getLong(LAST_PROCESSED_ID, 0L);
        if (lastProcessedId > 0) {
            log.info("ğŸ“ Resuming from last processed ID: {}", lastProcessedId);
        }
    }
    
    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        ExecutionContext executionContext = stepExecution.getExecutionContext();
        
        // ì²˜ë¦¬ í†µê³„ ì €ì¥
        executionContext.putLong("final.read.count", stepExecution.getReadCount());
        executionContext.putLong("final.write.count", stepExecution.getWriteCount());
        executionContext.putLong("final.skip.count", stepExecution.getSkipCount());
        
        // ì¬ì‹œì‘ì´ í•„ìš”í•œ ì¡°ê±´ í™•ì¸
        if (stepExecution.getSkipCount() > 50) {
            log.warn("âš ï¸ High skip count: {}. Step marked for review", stepExecution.getSkipCount());
            return new ExitStatus("FAILED", "High skip count requires review");
        }
        
        if (stepExecution.getWriteCount() == 0) {
            log.warn("âš ï¸ No items written. Possible data source issue");
            return new ExitStatus("FAILED", "No data processed");
        }
        
        log.info("âœ… Step completed successfully. Read: {}, Write: {}, Skip: {}", 
                stepExecution.getReadCount(), 
                stepExecution.getWriteCount(), 
                stepExecution.getSkipCount());
        
        return stepExecution.getExitStatus();
    }
    
    /**
     * í˜„ì¬ ì²˜ë¦¬ ì§€ì  ì—…ë°ì´íŠ¸ (ItemWriterì—ì„œ í˜¸ì¶œ)
     */
    public static void updateLastProcessedId(ExecutionContext context, Long id) {
        context.putLong(LAST_PROCESSED_ID, id);
    }
}
```

## ğŸ“Š ì‹¤ì‹œê°„ ë°°ì¹˜ ëª¨ë‹ˆí„°ë§

### 1. ë°°ì¹˜ ìƒíƒœ ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤
```java
package com.example.batchtutorial.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.*;
import org.springframework.batch.core.explore.JobExplorer;
import org.springframework.batch.core.launch.JobOperator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;
import java.util.stream.Collectors;

/**
 * ë°°ì¹˜ ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤
 */
@Slf4j
@Service
public class BatchMonitoringService {
    
    @Autowired
    private JobExplorer jobExplorer;
    
    @Autowired
    private JobOperator jobOperator;
    
    /**
     * ì‹¤í–‰ ì¤‘ì¸ ë°°ì¹˜ ëª©ë¡ ì¡°íšŒ
     */
    public List<BatchExecutionInfo> getRunningBatches() {
        List<BatchExecutionInfo> runningBatches = new ArrayList<>();
        
        Set<Long> runningExecutions = jobOperator.getRunningExecutions("*");
        
        for (Long executionId : runningExecutions) {
            JobExecution jobExecution = jobExplorer.getJobExecution(executionId);
            if (jobExecution != null) {
                BatchExecutionInfo info = createBatchInfo(jobExecution);
                runningBatches.add(info);
            }
        }
        
        return runningBatches;
    }
    
    /**
     * ìµœê·¼ ë°°ì¹˜ ì‹¤í–‰ ì´ë ¥ ì¡°íšŒ
     */
    public List<BatchExecutionInfo> getRecentBatchHistory(int count) {
        List<String> jobNames = jobExplorer.getJobNames();
        List<BatchExecutionInfo> recentExecutions = new ArrayList<>();
        
        for (String jobName : jobNames) {
            List<JobInstance> jobInstances = jobExplorer.getJobInstances(jobName, 0, count);
            
            for (JobInstance instance : jobInstances) {
                List<JobExecution> executions = jobExplorer.getJobExecutions(instance);
                for (JobExecution execution : executions) {
                    BatchExecutionInfo info = createBatchInfo(execution);
                    recentExecutions.add(info);
                }
            }
        }
        
        // ìµœê·¼ ì‹¤í–‰ ìˆœìœ¼ë¡œ ì •ë ¬
        return recentExecutions.stream()
                .sorted((a, b) -> b.getStartTime().compareTo(a.getStartTime()))
                .limit(count)
                .collect(Collectors.toList());
    }
    
    /**
     * íŠ¹ì • Jobì˜ ìƒì„¸ ì •ë³´ ì¡°íšŒ
     */
    public DetailedBatchInfo getBatchDetails(Long executionId) {
        JobExecution jobExecution = jobExplorer.getJobExecution(executionId);
        if (jobExecution == null) {
            return null;
        }
        
        DetailedBatchInfo details = new DetailedBatchInfo();
        details.setJobExecution(jobExecution);
        
        // Stepë³„ ìƒì„¸ ì •ë³´
        Collection<StepExecution> stepExecutions = jobExecution.getStepExecutions();
        List<StepExecutionInfo> stepInfos = new ArrayList<>();
        
        for (StepExecution stepExecution : stepExecutions) {
            StepExecutionInfo stepInfo = createStepInfo(stepExecution);
            stepInfos.add(stepInfo);
        }
        
        details.setStepExecutions(stepInfos);
        details.setOverallStatistics(calculateOverallStatistics(stepExecutions));
        
        return details;
    }
    
    /**
     * ë°°ì¹˜ ì‹¤í–‰ ì¤‘ë‹¨
     */
    public boolean stopBatch(Long executionId) {
        try {
            boolean stopped = jobOperator.stop(executionId);
            if (stopped) {
                log.info("ğŸ›‘ Batch execution {} stopped successfully", executionId);
            } else {
                log.warn("âš ï¸ Failed to stop batch execution {}", executionId);
            }
            return stopped;
        } catch (Exception e) {
            log.error("âŒ Error stopping batch execution {}: {}", executionId, e.getMessage());
            return false;
        }
    }
    
    /**
     * ë°°ì¹˜ ì¬ì‹œì‘
     */
    public Long restartBatch(Long executionId) {
        try {
            Long newExecutionId = jobOperator.restart(executionId);
            log.info("ğŸ”„ Batch execution {} restarted as {}", executionId, newExecutionId);
            return newExecutionId;
        } catch (Exception e) {
            log.error("âŒ Error restarting batch execution {}: {}", executionId, e.getMessage());
            return null;
        }
    }
    
    /**
     * ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬
     */
    public SystemHealthInfo getSystemHealth() {
        SystemHealthInfo health = new SystemHealthInfo();
        
        // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰
        Runtime runtime = Runtime.getRuntime();
        long maxMemory = runtime.maxMemory();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        health.setMemoryUsage((double) usedMemory / maxMemory * 100);
        
        // ì‹¤í–‰ ì¤‘ì¸ ë°°ì¹˜ ê°œìˆ˜
        health.setRunningBatchCount(getRunningBatches().size());
        
        // ìµœê·¼ ì‹¤íŒ¨í•œ ë°°ì¹˜ ê°œìˆ˜
        List<BatchExecutionInfo> recentBatches = getRecentBatchHistory(50);
        long failedCount = recentBatches.stream()
                .filter(batch -> "FAILED".equals(batch.getStatus()))
                .count();
        health.setRecentFailureCount(failedCount);
        
        // ì „ì²´ ìƒíƒœ ê²°ì •
        if (health.getMemoryUsage() > 90 || failedCount > 5) {
            health.setOverallStatus("CRITICAL");
        } else if (health.getMemoryUsage() > 70 || failedCount > 2) {
            health.setOverallStatus("WARNING");
        } else {
            health.setOverallStatus("HEALTHY");
        }
        
        return health;
    }
    
    // í—¬í¼ ë©”ì„œë“œë“¤
    private BatchExecutionInfo createBatchInfo(JobExecution jobExecution) {
        BatchExecutionInfo info = new BatchExecutionInfo();
        info.setExecutionId(jobExecution.getId());
        info.setJobName(jobExecution.getJobInstance().getJobName());
        info.setStatus(jobExecution.getStatus().toString());
        info.setStartTime(LocalDateTime.ofInstant(jobExecution.getStartTime().toInstant(), ZoneId.systemDefault()));
        
        if (jobExecution.getEndTime() != null) {
            info.setEndTime(LocalDateTime.ofInstant(jobExecution.getEndTime().toInstant(), ZoneId.systemDefault()));
            info.setDuration(Duration.between(info.getStartTime(), info.getEndTime()));
        }
        
        // ì§„í–‰ë¥  ê³„ì‚°
        Collection<StepExecution> stepExecutions = jobExecution.getStepExecutions();
        if (!stepExecutions.isEmpty()) {
            long totalRead = stepExecutions.stream().mapToLong(StepExecution::getReadCount).sum();
            long totalWrite = stepExecutions.stream().mapToLong(StepExecution::getWriteCount).sum();
            
            info.setTotalReadCount(totalRead);
            info.setTotalWriteCount(totalWrite);
            info.setProgress(totalRead > 0 ? (double) totalWrite / totalRead * 100 : 0);
        }
        
        return info;
    }
    
    private StepExecutionInfo createStepInfo(StepExecution stepExecution) {
        StepExecutionInfo info = new StepExecutionInfo();
        info.setStepName(stepExecution.getStepName());
        info.setStatus(stepExecution.getStatus().toString());
        info.setReadCount(stepExecution.getReadCount());
        info.setWriteCount(stepExecution.getWriteCount());
        info.setSkipCount(stepExecution.getSkipCount());
        info.setCommitCount(stepExecution.getCommitCount());
        
        if (stepExecution.getStartTime() != null && stepExecution.getEndTime() != null) {
            LocalDateTime start = LocalDateTime.ofInstant(stepExecution.getStartTime().toInstant(), ZoneId.systemDefault());
            LocalDateTime end = LocalDateTime.ofInstant(stepExecution.getEndTime().toInstant(), ZoneId.systemDefault());
            info.setDuration(Duration.between(start, end));
            
            // ì²˜ë¦¬ ì†ë„ ê³„ì‚°
            long durationSeconds = info.getDuration().getSeconds();
            if (durationSeconds > 0) {
                info.setThroughput((double) stepExecution.getWriteCount() / durationSeconds);
            }
        }
        
        return info;
    }
    
    private Map<String, Object> calculateOverallStatistics(Collection<StepExecution> stepExecutions) {
        Map<String, Object> stats = new HashMap<>();
        
        long totalRead = stepExecutions.stream().mapToLong(StepExecution::getReadCount).sum();
        long totalWrite = stepExecutions.stream().mapToLong(StepExecution::getWriteCount).sum();
        long totalSkip = stepExecutions.stream().mapToLong(StepExecution::getSkipCount).sum();
        
        stats.put("totalRead", totalRead);
        stats.put("totalWrite", totalWrite);
        stats.put("totalSkip", totalSkip);
        stats.put("successRate", totalRead > 0 ? (double) totalWrite / totalRead * 100 : 0);
        
        return stats;
    }
}

// ë°ì´í„° í´ë˜ìŠ¤ë“¤
@Data
class BatchExecutionInfo {
    private Long executionId;
    private String jobName;
    private String status;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private Duration duration;
    private Long totalReadCount;
    private Long totalWriteCount;
    private Double progress;
}

@Data
class DetailedBatchInfo {
    private JobExecution jobExecution;
    private List<StepExecutionInfo> stepExecutions;
    private Map<String, Object> overallStatistics;
}

@Data
class StepExecutionInfo {
    private String stepName;
    private String status;
    private int readCount;
    private int writeCount;
    private int skipCount;
    private int commitCount;
    private Duration duration;
    private Double throughput;
}

@Data
class SystemHealthInfo {
    private String overallStatus;
    private Double memoryUsage;
    private Integer runningBatchCount;
    private Long recentFailureCount;
    private LocalDateTime checkedAt = LocalDateTime.now();
}
```

### 2. ë°°ì¹˜ ëª¨ë‹ˆí„°ë§ REST API
```java
package com.example.batchtutorial.controller;

import com.example.batchtutorial.service.BatchMonitoringService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

/**
 * ë°°ì¹˜ ëª¨ë‹ˆí„°ë§ REST API
 */
@Slf4j
@RestController
@RequestMapping("/api/batch")
public class BatchMonitoringController {
    
    @Autowired
    private BatchMonitoringService monitoringService;
    
    /**
     * ì‹¤í–‰ ì¤‘ì¸ ë°°ì¹˜ ëª©ë¡
     */
    @GetMapping("/running")
    public List<BatchExecutionInfo> getRunningBatches() {
        return monitoringService.getRunningBatches();
    }
    
    /**
     * ìµœê·¼ ë°°ì¹˜ ì‹¤í–‰ ì´ë ¥
     */
    @GetMapping("/history")
    public List<BatchExecutionInfo> getBatchHistory(
            @RequestParam(defaultValue = "20") int count) {
        return monitoringService.getRecentBatchHistory(count);
    }
    
    /**
     * íŠ¹ì • ë°°ì¹˜ ìƒì„¸ ì •ë³´
     */
    @GetMapping("/{executionId}")
    public ResponseEntity<DetailedBatchInfo> getBatchDetails(@PathVariable Long executionId) {
        DetailedBatchInfo details = monitoringService.getBatchDetails(executionId);
        if (details != null) {
            return ResponseEntity.ok(details);
        } else {
            return ResponseEntity.notFound().build();
        }
    }
    
    /**
     * ë°°ì¹˜ ì¤‘ë‹¨
     */
    @PostMapping("/{executionId}/stop")
    public ResponseEntity<Map<String, Object>> stopBatch(@PathVariable Long executionId) {
        boolean stopped = monitoringService.stopBatch(executionId);
        return ResponseEntity.ok(Map.of(
            "success", stopped,
            "message", stopped ? "Batch stopped successfully" : "Failed to stop batch"
        ));
    }
    
    /**
     * ë°°ì¹˜ ì¬ì‹œì‘
     */
    @PostMapping("/{executionId}/restart")
    public ResponseEntity<Map<String, Object>> restartBatch(@PathVariable Long executionId) {
        Long newExecutionId = monitoringService.restartBatch(executionId);
        if (newExecutionId != null) {
            return ResponseEntity.ok(Map.of(
                "success", true,
                "newExecutionId", newExecutionId,
                "message", "Batch restarted successfully"
            ));
        } else {
            return ResponseEntity.ok(Map.of(
                "success", false,
                "message", "Failed to restart batch"
            ));
        }
    }
    
    /**
     * ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬
     */
    @GetMapping("/health")
    public SystemHealthInfo getSystemHealth() {
        return monitoringService.getSystemHealth();
    }
    
    /**
     * ë°°ì¹˜ í†µê³„ ëŒ€ì‹œë³´ë“œ
     */
    @GetMapping("/dashboard")
    public Map<String, Object> getDashboardData() {
        List<BatchExecutionInfo> runningBatches = monitoringService.getRunningBatches();
        List<BatchExecutionInfo> recentHistory = monitoringService.getRecentBatchHistory(100);
        SystemHealthInfo health = monitoringService.getSystemHealth();
        
        // ì„±ê³µë¥  ê³„ì‚°
        long totalBatches = recentHistory.size();
        long successfulBatches = recentHistory.stream()
                .filter(batch -> "COMPLETED".equals(batch.getStatus()))
                .count();
        
        double successRate = totalBatches > 0 ? (double) successfulBatches / totalBatches * 100 : 0;
        
        return Map.of(
            "runningBatches", runningBatches,
            "recentHistory", recentHistory.stream().limit(10).toList(),
            "systemHealth", health,
            "statistics", Map.of(
                "totalBatches", totalBatches,
                "successfulBatches", successfulBatches,
                "successRate", successRate
            )
        );
    }
}
```

### 3. ì‹¤ì‹œê°„ ì•Œë¦¼ ì‹œìŠ¤í…œ
```java
package com.example.batchtutorial.notification;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.batch.core.StepExecution;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.ZoneId;

/**
 * ë°°ì¹˜ ì‹¤í–‰ ê²°ê³¼ì— ë”°ë¥¸ ì•Œë¦¼ ë°œì†¡
 */
@Slf4j
@Component
public class BatchNotificationService implements JobExecutionListener {
    
    @Value("${batch.notification.email.enabled:true}")
    private boolean emailNotificationEnabled;
    
    @Value("${batch.notification.slack.enabled:false}")
    private boolean slackNotificationEnabled;
    
    @Value("${batch.notification.threshold.duration:300}")  // 5ë¶„
    private long longRunningThresholdSeconds;
    
    @Override
    public void beforeJob(JobExecution jobExecution) {
        String jobName = jobExecution.getJobInstance().getJobName();
        log.info("ğŸ“§ Job started notification: {}", jobName);
        
        if (emailNotificationEnabled) {
            sendJobStartNotification(jobName);
        }
    }
    
    @Override
    public void afterJob(JobExecution jobExecution) {
        String jobName = jobExecution.getJobInstance().getJobName();
        String status = jobExecution.getExitStatus().getExitCode();
        
        LocalDateTime startTime = LocalDateTime.ofInstant(
                jobExecution.getStartTime().toInstant(), ZoneId.systemDefault());
        LocalDateTime endTime = LocalDateTime.ofInstant(
                jobExecution.getEndTime().toInstant(), ZoneId.systemDefault());
        Duration duration = Duration.between(startTime, endTime);
        
        // ì‹¤í–‰ í†µê³„ ìˆ˜ì§‘
        JobExecutionSummary summary = createExecutionSummary(jobExecution, duration);
        
        // ìƒíƒœì— ë”°ë¥¸ ì•Œë¦¼ ë°œì†¡
        switch (status) {
            case "COMPLETED" -> handleSuccessfulCompletion(summary);
            case "FAILED" -> handleFailure(summary);
            case "STOPPED" -> handleStopped(summary);
            default -> handleUnknownStatus(summary);
        }
        
        // ì¥ì‹œê°„ ì‹¤í–‰ ì•Œë¦¼
        if (duration.getSeconds() > longRunningThresholdSeconds) {
            sendLongRunningJobAlert(summary);
        }
    }
    
    private void handleSuccessfulCompletion(JobExecutionSummary summary) {
        log.info("âœ… Job completed successfully: {}", summary.getJobName());
        
        if (emailNotificationEnabled) {
            sendSuccessNotification(summary);
        }
        
        if (slackNotificationEnabled) {
            sendSlackSuccessMessage(summary);
        }
    }
    
    private void handleFailure(JobExecutionSummary summary) {
        log.error("âŒ Job failed: {}", summary.getJobName());
        
        // ì‹¤íŒ¨ ì‹œ í•­ìƒ ì•Œë¦¼ ë°œì†¡
        sendFailureNotification(summary);
        
        if (slackNotificationEnabled) {
            sendSlackFailureAlert(summary);
        }
        
        // ê¸´ê¸‰ ì•Œë¦¼ (SMS, ì „í™” ë“±) - ì‹¤ì œ êµ¬í˜„ í•„ìš”
        if (summary.isCritical()) {
            sendUrgentAlert(summary);
        }
    }
    
    private void handleStopped(JobExecutionSummary summary) {
        log.warn("ğŸ›‘ Job was stopped: {}", summary.getJobName());
        sendJobStoppedNotification(summary);
    }
    
    private JobExecutionSummary createExecutionSummary(JobExecution jobExecution, Duration duration) {
        JobExecutionSummary summary = new JobExecutionSummary();
        summary.setJobName(jobExecution.getJobInstance().getJobName());
        summary.setExecutionId(jobExecution.getId());
        summary.setStatus(jobExecution.getExitStatus().getExitCode());
        summary.setDuration(duration);
        summary.setStartTime(LocalDateTime.ofInstant(
                jobExecution.getStartTime().toInstant(), ZoneId.systemDefault()));
        summary.setEndTime(LocalDateTime.ofInstant(
                jobExecution.getEndTime().toInstant(), ZoneId.systemDefault()));
        
        // Step í†µê³„ ìˆ˜ì§‘
        long totalRead = 0, totalWrite = 0, totalSkip = 0;
        StringBuilder stepDetails = new StringBuilder();
        
        for (StepExecution step : jobExecution.getStepExecutions()) {
            totalRead += step.getReadCount();
            totalWrite += step.getWriteCount();
            totalSkip += step.getSkipCount();
            
            stepDetails.append(String.format(
                "- %s: Read=%d, Write=%d, Skip=%d%n", 
                step.getStepName(), step.getReadCount(), step.getWriteCount(), step.getSkipCount()
            ));
        }
        
        summary.setTotalRead(totalRead);
        summary.setTotalWrite(totalWrite);
        summary.setTotalSkip(totalSkip);
        summary.setStepDetails(stepDetails.toString());
        
        // ì¤‘ìš”ë„ íŒë‹¨
        summary.setCritical(jobExecution.getJobInstance().getJobName().contains("CRITICAL") || 
                           totalSkip > 1000 || 
                           duration.getSeconds() > 3600); // 1ì‹œê°„ ì´ìƒ
        
        return summary;
    }
    
    private void sendSuccessNotification(JobExecutionSummary summary) {
        String subject = String.format("âœ… Batch Job Completed: %s", summary.getJobName());
        String body = String.format("""
            Job: %s
            Status: COMPLETED
            Duration: %d minutes
            
            Statistics:
            - Read: %,d items
            - Write: %,d items
            - Skip: %,d items
            - Success Rate: %.2f%%
            
            Step Details:
            %s
            """, 
            summary.getJobName(),
            summary.getDuration().toMinutes(),
            summary.getTotalRead(),
            summary.getTotalWrite(),
            summary.getTotalSkip(),
            summary.getTotalRead() > 0 ? (double) summary.getTotalWrite() / summary.getTotalRead() * 100 : 0,
            summary.getStepDetails()
        );
        
        sendEmailNotification(subject, body);
    }
    
    private void sendFailureNotification(JobExecutionSummary summary) {
        String subject = String.format("âŒ Batch Job FAILED: %s", summary.getJobName());
        String body = String.format("""
            ğŸš¨ BATCH JOB FAILURE ALERT ğŸš¨
            
            Job: %s
            Status: FAILED
            Execution ID: %d
            Duration: %d minutes
            
            Failure occurred at: %s
            
            Statistics:
            - Read: %,d items
            - Write: %,d items  
            - Skip: %,d items
            
            Step Details:
            %s
            
            Please check the logs and take appropriate action.
            """,
            summary.getJobName(),
            summary.getExecutionId(),
            summary.getDuration().toMinutes(),
            summary.getEndTime(),
            summary.getTotalRead(),
            summary.getTotalWrite(),
            summary.getTotalSkip(),
            summary.getStepDetails()
        );
        
        sendEmailNotification(subject, body);
    }
    
    private void sendEmailNotification(String subject, String body) {
        // ì‹¤ì œ ì´ë©”ì¼ ë°œì†¡ êµ¬í˜„
        log.info("ğŸ“§ EMAIL NOTIFICATION: {}", subject);
        log.debug("Email body: {}", body);
        
        // JavaMailSender ë“±ì„ ì‚¬ìš©í•œ ì‹¤ì œ ì´ë©”ì¼ ë°œì†¡ ë¡œì§ êµ¬í˜„
        // emailService.sendNotification(subject, body);
    }
    
    private void sendSlackSuccessMessage(JobExecutionSummary summary) {
        String message = String.format(
            "âœ… Batch job `%s` completed successfully in %d minutes. Processed %,d items.",
            summary.getJobName(), summary.getDuration().toMinutes(), summary.getTotalWrite()
        );
        
        sendSlackMessage(message, "good");
    }
    
    private void sendSlackFailureAlert(JobExecutionSummary summary) {
        String message = String.format(
            "ğŸš¨ Batch job `%s` FAILED after %d minutes. Execution ID: %d. Please check immediately!",
            summary.getJobName(), summary.getDuration().toMinutes(), summary.getExecutionId()
        );
        
        sendSlackMessage(message, "danger");
    }
    
    private void sendSlackMessage(String message, String color) {
        // ì‹¤ì œ Slack API í˜¸ì¶œ êµ¬í˜„
        log.info("ğŸ“± SLACK NOTIFICATION ({}): {}", color, message);
        
        // Slack WebClientë¥¼ ì‚¬ìš©í•œ ë©”ì‹œì§€ ë°œì†¡ ë¡œì§ êµ¬í˜„
        // slackService.sendMessage(message, color);
    }
    
    // ê¸°íƒ€ ì•Œë¦¼ ë©”ì„œë“œë“¤...
    private void sendJobStartNotification(String jobName) { /* êµ¬í˜„ */ }
    private void handleUnknownStatus(JobExecutionSummary summary) { /* êµ¬í˜„ */ }
    private void sendLongRunningJobAlert(JobExecutionSummary summary) { /* êµ¬í˜„ */ }
    private void sendJobStoppedNotification(JobExecutionSummary summary) { /* êµ¬í˜„ */ }
    private void sendUrgentAlert(JobExecutionSummary summary) { /* êµ¬í˜„ */ }
}

@Data
class JobExecutionSummary {
    private String jobName;
    private Long executionId;
    private String status;
    private Duration duration;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private long totalRead;
    private long totalWrite;
    private long totalSkip;
    private String stepDetails;
    private boolean critical;
}
```

ì´ì œ í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œ ì•ˆì •ì ìœ¼ë¡œ ìš´ì˜í•  ìˆ˜ ìˆëŠ” ì™„ì „í•œ ì—ëŸ¬ ì²˜ë¦¬, ì¬ì‹œì‘, ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì´ êµ¬ì¶•ë˜ì—ˆìŠµë‹ˆë‹¤! ë§ˆì§€ë§‰ ë‹¨ê³„ì—ì„œëŠ” Spring Batchì˜ ê³ ê¸‰ í™œìš©ë²•ê³¼ ì‹¤ë¬´ íŒì„ í•™ìŠµí•˜ê² ìŠµë‹ˆë‹¤.