# 07. ë°°ì¹˜ í•™ìŠµ 3ë‹¨ê³„: ë°ì´í„°ë² ì´ìŠ¤ ì—°ë™ ë° ê³ ê¸‰ ì²˜ë¦¬

## ğŸ¯ í•™ìŠµ ëª©í‘œ
- ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ë°ì´í„°ë¥¼ ì½ì–´ì˜¤ëŠ” ItemReader êµ¬í˜„
- ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ í¬í•¨ëœ ItemProcessor ì‘ì„±
- ì—¬ëŸ¬ ë°ì´í„°ë² ì´ìŠ¤ì— ë™ì‹œì— ì €ì¥í•˜ëŠ” CompositeWriter êµ¬í˜„
- ì¡°ê±´ë¶€ Step ì‹¤í–‰ ë° Flow ì œì–´ í•™ìŠµ

## ğŸ“Š ì‹œë‚˜ë¦¬ì˜¤: ì£¼ë¬¸ ë°ì´í„° ì²˜ë¦¬ ì‹œìŠ¤í…œ

### ë¹„ì¦ˆë‹ˆìŠ¤ ìš”êµ¬ì‚¬í•­
1. **ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸**: ë¯¸ì²˜ë¦¬ ì£¼ë¬¸ì„ ë°°ì†¡ ì¤€ë¹„ ìƒíƒœë¡œ ë³€ê²½
2. **ì¬ê³  ì°¨ê°**: ì£¼ë¬¸ ìƒí’ˆì˜ ì¬ê³  ìˆ˜ëŸ‰ ê°ì†Œ
3. **í¬ì¸íŠ¸ ì ë¦½**: ê³ ê°ë³„ êµ¬ë§¤ ê¸ˆì•¡ì— ë”°ë¥¸ í¬ì¸íŠ¸ ì ë¦½
4. **ì•Œë¦¼ ë°œì†¡**: ì²˜ë¦¬ ì™„ë£Œëœ ì£¼ë¬¸ì— ëŒ€í•œ ì•Œë¦¼ (ë¡œê·¸ë§Œ ê¸°ë¡)
5. **í†µê³„ ì—…ë°ì´íŠ¸**: ì¼ì¼ ë§¤ì¶œ í†µê³„ í…Œì´ë¸” ì—…ë°ì´íŠ¸

## ğŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ê³„

### 1. ì—”í‹°í‹° í´ë˜ìŠ¤ë“¤

#### Order ì—”í‹°í‹°
```java
package com.example.batchtutorial.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "orders")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "customer_id", nullable = false)
    private Long customerId;
    
    @Column(name = "order_number", nullable = false, unique = true, length = 50)
    private String orderNumber;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private OrderStatus status;
    
    @Column(name = "total_amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal totalAmount;
    
    @Column(name = "order_date", nullable = false)
    private LocalDateTime orderDate;
    
    @Column(name = "processed_date")
    private LocalDateTime processedDate;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // ì£¼ë¬¸ ì•„ì´í…œë“¤ê³¼ì˜ ê´€ê³„
    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<OrderItem> orderItems;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}

// ì£¼ë¬¸ ìƒíƒœ ì—´ê±°í˜•
enum OrderStatus {
    PENDING,        // ë¯¸ì²˜ë¦¬
    PROCESSING,     // ì²˜ë¦¬ì¤‘
    SHIPPED,        // ë°°ì†¡ì™„ë£Œ
    DELIVERED,      // ë°°ë‹¬ì™„ë£Œ
    CANCELLED       // ì·¨ì†Œ
}
```

#### OrderItem ì—”í‹°í‹°
```java
package com.example.batchtutorial.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Entity
@Table(name = "order_items")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrderItem {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;
    
    @Column(name = "product_id", nullable = false)
    private Long productId;
    
    @Column(name = "product_name", nullable = false, length = 100)
    private String productName;
    
    @Column(name = "quantity", nullable = false)
    private Integer quantity;
    
    @Column(name = "unit_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal unitPrice;
    
    @Column(name = "total_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal totalPrice;
}
```

#### Product ì—”í‹°í‹° (ì¬ê³  ê´€ë¦¬)
```java
package com.example.batchtutorial.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "products")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;
    
    @Column(name = "price", nullable = false, precision = 10, scale = 2)
    private BigDecimal price;
    
    @Column(name = "stock_quantity", nullable = false)
    private Integer stockQuantity;
    
    @Column(name = "category", length = 50)
    private String category;
    
    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate  
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
    
    // ì¬ê³  ì°¨ê° ë©”ì„œë“œ
    public boolean decreaseStock(int quantity) {
        if (this.stockQuantity >= quantity) {
            this.stockQuantity -= quantity;
            return true;
        }
        return false;
    }
}
```

#### Customer ì—”í‹°í‹° (í¬ì¸íŠ¸ ì ë¦½)
```java
package com.example.batchtutorial.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "customers")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Customer {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;
    
    @Column(name = "email", nullable = false, unique = true, length = 100)
    private String email;
    
    @Column(name = "phone", length = 20)
    private String phone;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "grade", nullable = false)
    private CustomerGrade grade = CustomerGrade.BRONZE;
    
    @Column(name = "total_points", nullable = false, precision = 10, scale = 2)
    private BigDecimal totalPoints = BigDecimal.ZERO;
    
    @Column(name = "total_purchase_amount", nullable = false, precision = 15, scale = 2)
    private BigDecimal totalPurchaseAmount = BigDecimal.ZERO;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
    
    // í¬ì¸íŠ¸ ì ë¦½
    public void addPoints(BigDecimal points) {
        this.totalPoints = this.totalPoints.add(points);
    }
    
    // êµ¬ë§¤ ê¸ˆì•¡ ëˆ„ì 
    public void addPurchaseAmount(BigDecimal amount) {
        this.totalPurchaseAmount = this.totalPurchaseAmount.add(amount);
        updateGrade();
    }
    
    // ê³ ê° ë“±ê¸‰ ì—…ë°ì´íŠ¸
    private void updateGrade() {
        BigDecimal amount = this.totalPurchaseAmount;
        if (amount.compareTo(new BigDecimal("1000000")) >= 0) {
            this.grade = CustomerGrade.DIAMOND;
        } else if (amount.compareTo(new BigDecimal("500000")) >= 0) {
            this.grade = CustomerGrade.GOLD;
        } else if (amount.compareTo(new BigDecimal("100000")) >= 0) {
            this.grade = CustomerGrade.SILVER;
        } else {
            this.grade = CustomerGrade.BRONZE;
        }
    }
}

// ê³ ê° ë“±ê¸‰
enum CustomerGrade {
    BRONZE(0.01),   // 1%
    SILVER(0.02),   // 2%
    GOLD(0.03),     // 3%
    DIAMOND(0.05);  // 5%
    
    private final double pointsRate;
    
    CustomerGrade(double pointsRate) {
        this.pointsRate = pointsRate;
    }
    
    public double getPointsRate() {
        return pointsRate;
    }
}
```

#### DailySales ì—”í‹°í‹° (í†µê³„)
```java
package com.example.batchtutorial.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "daily_sales")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class DailySales {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "sales_date", nullable = false, unique = true)
    private LocalDate salesDate;
    
    @Column(name = "total_orders", nullable = false)
    private Long totalOrders = 0L;
    
    @Column(name = "total_amount", nullable = false, precision = 15, scale = 2)
    private BigDecimal totalAmount = BigDecimal.ZERO;
    
    @Column(name = "average_order_amount", precision = 10, scale = 2)
    private BigDecimal averageOrderAmount = BigDecimal.ZERO;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }
    
    @PreUpdate
    protected void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
    
    // ì£¼ë¬¸ ì¶”ê°€
    public void addOrder(BigDecimal orderAmount) {
        this.totalOrders++;
        this.totalAmount = this.totalAmount.add(orderAmount);
        updateAverageAmount();
    }
    
    // í‰ê·  ì£¼ë¬¸ ê¸ˆì•¡ ê³„ì‚°
    private void updateAverageAmount() {
        if (totalOrders > 0) {
            this.averageOrderAmount = totalAmount.divide(
                BigDecimal.valueOf(totalOrders), 2, BigDecimal.ROUND_HALF_UP
            );
        }
    }
}
```

### 2. Repository ì¸í„°í˜ì´ìŠ¤ë“¤

```java
package com.example.batchtutorial.repository;

import com.example.batchtutorial.entity.Order;
import com.example.batchtutorial.entity.OrderStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    // íŠ¹ì • ìƒíƒœì˜ ì£¼ë¬¸ë“¤ ì¡°íšŒ
    List<Order> findByStatusOrderByOrderDateAsc(OrderStatus status);
    
    // ì²˜ë¦¬ë˜ì§€ ì•Šì€ ì£¼ë¬¸ë“¤ ì¡°íšŒ (Batch Readerìš©)
    @Query("SELECT o FROM Order o WHERE o.status = :status ORDER BY o.orderDate ASC")
    List<Order> findUnprocessedOrders(@Param("status") OrderStatus status);
    
    // íŠ¹ì • ê¸°ê°„ì˜ ì£¼ë¬¸ ì¡°íšŒ
    List<Order> findByOrderDateBetween(LocalDateTime startDate, LocalDateTime endDate);
    
    // ê³ ê°ë³„ ì£¼ë¬¸ ì¡°íšŒ
    List<Order> findByCustomerIdOrderByOrderDateDesc(Long customerId);
}

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // í™œì„±í™”ëœ ìƒí’ˆë“¤ ì¡°íšŒ
    List<Product> findByIsActiveTrueOrderByNameAsc();
    
    // ì¬ê³  ë¶€ì¡± ìƒí’ˆ ì¡°íšŒ
    List<Product> findByStockQuantityLessThanAndIsActiveTrue(Integer threshold);
    
    // ì¹´í…Œê³ ë¦¬ë³„ ìƒí’ˆ ì¡°íšŒ
    List<Product> findByCategoryAndIsActiveTrueOrderByNameAsc(String category);
}

@Repository
public interface CustomerRepository extends JpaRepository<Customer, Long> {
    
    // ì´ë©”ì¼ë¡œ ê³ ê° ì¡°íšŒ
    Optional<Customer> findByEmail(String email);
    
    // ë“±ê¸‰ë³„ ê³ ê° ì¡°íšŒ
    List<Customer> findByGradeOrderByTotalPurchaseAmountDesc(CustomerGrade grade);
}

@Repository
public interface DailySalesRepository extends JpaRepository<DailySales, Long> {
    
    // íŠ¹ì • ë‚ ì§œì˜ ë§¤ì¶œ ì¡°íšŒ
    Optional<DailySales> findBySalesDate(LocalDate salesDate);
    
    // ê¸°ê°„ë³„ ë§¤ì¶œ ì¡°íšŒ
    List<DailySales> findBySalesDateBetweenOrderBySalesDateAsc(LocalDate startDate, LocalDate endDate);
}
```

## ğŸ”§ ê³ ê¸‰ ë°°ì¹˜ ì»´í¬ë„ŒíŠ¸ êµ¬í˜„

### 1. ë°ì´í„°ë² ì´ìŠ¤ ItemReader
```java
package com.example.batchtutorial.batch.reader;

import com.example.batchtutorial.entity.Order;
import com.example.batchtutorial.entity.OrderStatus;
import org.springframework.batch.item.database.JpaPagingItemReader;
import org.springframework.batch.item.database.builder.JpaPagingItemReaderBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import jakarta.persistence.EntityManagerFactory;
import java.util.Map;

/**
 * ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì£¼ë¬¸ ë°ì´í„°ë¥¼ ì½ëŠ” ItemReader
 */
@Configuration
public class OrderItemReaderConfig {
    
    @Autowired
    private EntityManagerFactory entityManagerFactory;
    
    /**
     * ë¯¸ì²˜ë¦¬ ì£¼ë¬¸ì„ í˜ì´ì§•ìœ¼ë¡œ ì½ì–´ì˜¤ëŠ” Reader
     */
    @Bean
    public JpaPagingItemReader<Order> pendingOrderReader() {
        return new JpaPagingItemReaderBuilder<Order>()
                .name("pendingOrderReader")
                .entityManagerFactory(entityManagerFactory)
                .queryString("SELECT o FROM Order o WHERE o.status = :status ORDER BY o.orderDate ASC")
                .parameterValues(Map.of("status", OrderStatus.PENDING))
                .pageSize(10)  // í˜ì´ì§€ í¬ê¸° 10
                .build();
    }
    
    /**
     * ì²˜ë¦¬ì¤‘ì¸ ì£¼ë¬¸ì„ ì½ì–´ì˜¤ëŠ” Reader
     */
    @Bean
    public JpaPagingItemReader<Order> processingOrderReader() {
        return new JpaPagingItemReaderBuilder<Order>()
                .name("processingOrderReader")  
                .entityManagerFactory(entityManagerFactory)
                .queryString("SELECT o FROM Order o WHERE o.status = :status ORDER BY o.orderDate ASC")
                .parameterValues(Map.of("status", OrderStatus.PROCESSING))
                .pageSize(5)
                .build();
    }
}
```

### 2. ë³µí•© ItemProcessor
```java
package com.example.batchtutorial.batch.processor;

import com.example.batchtutorial.entity.*;
import com.example.batchtutorial.repository.CustomerRepository;
import com.example.batchtutorial.repository.ProductRepository;
import com.example.batchtutorial.dto.ProcessedOrderDto;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.Optional;

/**
 * ì£¼ë¬¸ ì²˜ë¦¬ë¥¼ ìœ„í•œ ë³µí•© ItemProcessor
 */
@Slf4j
@Configuration
public class OrderProcessorConfig {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private CustomerRepository customerRepository;
    
    /**
     * ì£¼ë¬¸ì„ ì²˜ë¦¬í•˜ëŠ” ë©”ì¸ Processor
     */
    @Bean
    public ItemProcessor<Order, ProcessedOrderDto> orderProcessor() {
        return new ItemProcessor<Order, ProcessedOrderDto>() {
            @Override
            public ProcessedOrderDto process(Order order) throws Exception {
                
                log.info("Processing order: {} (Customer: {})", 
                        order.getOrderNumber(), order.getCustomerId());
                
                try {
                    // 1. ê³ ê° ì •ë³´ ì¡°íšŒ ë° ê²€ì¦
                    Optional<Customer> customerOpt = customerRepository.findById(order.getCustomerId());
                    if (customerOpt.isEmpty()) {
                        log.warn("Customer not found for order {}: {}", 
                                order.getOrderNumber(), order.getCustomerId());
                        return null;  // ê³ ê°ì´ ì—†ìœ¼ë©´ ì²˜ë¦¬ ì¤‘ë‹¨
                    }
                    Customer customer = customerOpt.get();
                    
                    // 2. ì¬ê³  í™•ì¸ ë° ì°¨ê°
                    if (!processInventory(order)) {
                        log.warn("Insufficient stock for order: {}", order.getOrderNumber());
                        return null;  // ì¬ê³  ë¶€ì¡± ì‹œ ì²˜ë¦¬ ì¤‘ë‹¨
                    }
                    
                    // 3. ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸
                    order.setStatus(OrderStatus.PROCESSING);
                    order.setProcessedDate(LocalDateTime.now());
                    
                    // 4. ê³ ê° ì •ë³´ ì—…ë°ì´íŠ¸ (êµ¬ë§¤ ê¸ˆì•¡, í¬ì¸íŠ¸)
                    updateCustomer(customer, order);
                    
                    // 5. ì²˜ë¦¬ ê²°ê³¼ DTO ìƒì„±
                    ProcessedOrderDto result = new ProcessedOrderDto();
                    result.setOrder(order);
                    result.setCustomer(customer);
                    result.setProcessedAt(LocalDateTime.now());
                    result.setPointsEarned(calculatePoints(customer, order.getTotalAmount()));
                    
                    log.info("Successfully processed order: {} (Points earned: {})", 
                            order.getOrderNumber(), result.getPointsEarned());
                    
                    return result;
                    
                } catch (Exception e) {
                    log.error("Error processing order {}: {}", order.getOrderNumber(), e.getMessage(), e);
                    throw e;  // ì˜ˆì™¸ ë°œìƒ ì‹œ ì¬ë°œìƒ
                }
            }
        };
    }
    
    /**
     * ì¬ê³  ì²˜ë¦¬ (ì°¨ê°)
     */
    private boolean processInventory(Order order) {
        for (OrderItem item : order.getOrderItems()) {
            Optional<Product> productOpt = productRepository.findById(item.getProductId());
            
            if (productOpt.isEmpty()) {
                log.warn("Product not found: {}", item.getProductId());
                return false;
            }
            
            Product product = productOpt.get();
            
            if (!product.getIsActive()) {
                log.warn("Product is inactive: {}", product.getName());
                return false;
            }
            
            if (!product.decreaseStock(item.getQuantity())) {
                log.warn("Insufficient stock for product {}: required {}, available {}", 
                        product.getName(), item.getQuantity(), product.getStockQuantity());
                return false;
            }
            
            // ì¬ê³  ë³€ê²½ ì‚¬í•­ ì €ì¥
            productRepository.save(product);
            
            log.debug("Stock decreased for product {}: -{} (remaining: {})", 
                    product.getName(), item.getQuantity(), product.getStockQuantity());
        }
        
        return true;
    }
    
    /**
     * ê³ ê° ì •ë³´ ì—…ë°ì´íŠ¸
     */
    private void updateCustomer(Customer customer, Order order) {
        // êµ¬ë§¤ ê¸ˆì•¡ ëˆ„ì  (ë“±ê¸‰ ìë™ ì—…ë°ì´íŠ¸ í¬í•¨)
        customer.addPurchaseAmount(order.getTotalAmount());
        
        // í¬ì¸íŠ¸ ì ë¦½
        BigDecimal points = calculatePoints(customer, order.getTotalAmount());
        customer.addPoints(points);
        
        log.debug("Customer updated: {} (New grade: {}, Points added: {})", 
                customer.getName(), customer.getGrade(), points);
    }
    
    /**
     * í¬ì¸íŠ¸ ê³„ì‚° (ê³ ê° ë“±ê¸‰ì— ë”°ë¼)
     */
    private BigDecimal calculatePoints(Customer customer, BigDecimal orderAmount) {
        double pointsRate = customer.getGrade().getPointsRate();
        return orderAmount.multiply(BigDecimal.valueOf(pointsRate));
    }
}
```

### 3. ì²˜ë¦¬ ê²°ê³¼ DTO
```java
package com.example.batchtutorial.dto;

import com.example.batchtutorial.entity.Customer;
import com.example.batchtutorial.entity.Order;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * ì£¼ë¬¸ ì²˜ë¦¬ ê²°ê³¼ë¥¼ ë‹´ëŠ” DTO
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProcessedOrderDto {
    
    private Order order;
    private Customer customer;
    private LocalDateTime processedAt;
    private BigDecimal pointsEarned;
    private String notificationMessage;
    
    // ì•Œë¦¼ ë©”ì‹œì§€ ìƒì„±
    public String generateNotificationMessage() {
        if (notificationMessage == null) {
            notificationMessage = String.format(
                "ì•ˆë…•í•˜ì„¸ìš” %së‹˜! ì£¼ë¬¸ë²ˆí˜¸ %sì´ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤. %s í¬ì¸íŠ¸ê°€ ì ë¦½ë˜ì—ˆìŠµë‹ˆë‹¤.",
                customer.getName(),
                order.getOrderNumber(),
                pointsEarned
            );
        }
        return notificationMessage;
    }
}
```

### 4. Composite ItemWriter
```java
package com.example.batchtutorial.batch.writer;

import com.example.batchtutorial.dto.ProcessedOrderDto;
import com.example.batchtutorial.entity.DailySales;
import com.example.batchtutorial.repository.CustomerRepository;
import com.example.batchtutorial.repository.DailySalesRepository;
import com.example.batchtutorial.repository.OrderRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.item.Chunk;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

/**
 * ë³µí•© ë°ì´í„° ì €ì¥ì„ ìœ„í•œ ItemWriter ì„¤ì •
 */
@Slf4j
@Configuration
public class OrderItemWriterConfig {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private CustomerRepository customerRepository;
    
    @Autowired
    private DailySalesRepository dailySalesRepository;
    
    /**
     * ì²˜ë¦¬ëœ ì£¼ë¬¸ ë°ì´í„°ë¥¼ ì—¬ëŸ¬ í…Œì´ë¸”ì— ì €ì¥í•˜ëŠ” Writer
     */
    @Bean
    public ItemWriter<ProcessedOrderDto> processedOrderWriter() {
        return new ItemWriter<ProcessedOrderDto>() {
            @Override
            public void write(Chunk<? extends ProcessedOrderDto> chunk) throws Exception {
                
                List<? extends ProcessedOrderDto> items = chunk.getItems();
                log.info("Writing {} processed orders", items.size());
                
                int savedOrders = 0;
                int updatedCustomers = 0;
                int statisticsUpdated = 0;
                int notificationsSent = 0;
                
                for (ProcessedOrderDto dto : items) {
                    try {
                        // 1. ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸
                        orderRepository.save(dto.getOrder());
                        savedOrders++;
                        
                        // 2. ê³ ê° ì •ë³´ ì—…ë°ì´íŠ¸
                        customerRepository.save(dto.getCustomer());
                        updatedCustomers++;
                        
                        // 3. ì¼ì¼ ë§¤ì¶œ í†µê³„ ì—…ë°ì´íŠ¸
                        updateDailySalesStatistics(dto);
                        statisticsUpdated++;
                        
                        // 4. ì•Œë¦¼ ë°œì†¡ (ë¡œê·¸ë§Œ ê¸°ë¡)
                        sendNotification(dto);
                        notificationsSent++;
                        
                        log.debug("Successfully wrote order: {}", dto.getOrder().getOrderNumber());
                        
                    } catch (Exception e) {
                        log.error("Failed to write processed order {}: {}", 
                                dto.getOrder().getOrderNumber(), e.getMessage(), e);
                        throw e;  // ì˜ˆì™¸ ë°œìƒ ì‹œ ì „ì²´ ì²­í¬ ë¡¤ë°±
                    }
                }
                
                log.info("Chunk write completed - Orders: {}, Customers: {}, Stats: {}, Notifications: {}", 
                        savedOrders, updatedCustomers, statisticsUpdated, notificationsSent);
            }
        };
    }
    
    /**
     * ì¼ì¼ ë§¤ì¶œ í†µê³„ ì—…ë°ì´íŠ¸
     */
    private void updateDailySalesStatistics(ProcessedOrderDto dto) {
        LocalDate orderDate = dto.getOrder().getOrderDate().toLocalDate();
        
        Optional<DailySales> existingSalesOpt = dailySalesRepository.findBySalesDate(orderDate);
        
        DailySales dailySales;
        if (existingSalesOpt.isPresent()) {
            dailySales = existingSalesOpt.get();
        } else {
            dailySales = new DailySales();
            dailySales.setSalesDate(orderDate);
        }
        
        // ì£¼ë¬¸ ì¶”ê°€ (ë‚´ë¶€ì—ì„œ í‰ê·  ê³„ì‚° ìˆ˜í–‰)
        dailySales.addOrder(dto.getOrder().getTotalAmount());
        
        // ì €ì¥
        dailySalesRepository.save(dailySales);
        
        log.debug("Updated daily sales for {}: {} orders, total amount {}", 
                orderDate, dailySales.getTotalOrders(), dailySales.getTotalAmount());
    }
    
    /**
     * ì•Œë¦¼ ë°œì†¡ (ì‹¤ì œë¡œëŠ” ë¡œê·¸ë§Œ ê¸°ë¡)
     */
    private void sendNotification(ProcessedOrderDto dto) {
        String message = dto.generateNotificationMessage();
        
        // ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” ì´ë©”ì¼, SMS, í‘¸ì‹œ ì•Œë¦¼ ë“±ì„ ë°œì†¡
        log.info("ğŸ“§ [NOTIFICATION] {}", message);
        
        // ì•Œë¦¼ ë°œì†¡ ì‹¤íŒ¨ ì‹œë®¬ë ˆì´ì…˜ (ëœë¤í•˜ê²Œ)
        if (Math.random() < 0.1) {  // 10% í™•ë¥ ë¡œ ì‹¤íŒ¨
            log.warn("âš ï¸ Notification delivery failed for order: {}", dto.getOrder().getOrderNumber());
            // ì‹¤ì œë¡œëŠ” ì¬ì‹œë„ íì— ë„£ê±°ë‚˜ ë³„ë„ ì²˜ë¦¬
        }
    }
}
```

## ğŸ”„ ì¡°ê±´ë¶€ Stepê³¼ Flow ì œì–´

### ë©”ì¸ ë°°ì¹˜ ì„¤ì •
```java
package com.example.batchtutorial.config;

import com.example.batchtutorial.dto.ProcessedOrderDto;
import com.example.batchtutorial.entity.Order;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.*;
import org.springframework.batch.core.job.builder.JobBuilder;
import org.springframework.batch.core.job.flow.FlowExecutionStatus;
import org.springframework.batch.core.job.flow.JobExecutionDecider;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.PlatformTransactionManager;

/**
 * ê³ ê¸‰ ì£¼ë¬¸ ì²˜ë¦¬ ë°°ì¹˜ ì„¤ì •
 */
@Slf4j
@Configuration
public class AdvancedOrderBatchConfig {
    
    @Autowired
    private JobRepository jobRepository;
    
    @Autowired
    private PlatformTransactionManager transactionManager;
    
    /**
     * ë©”ì¸ ì£¼ë¬¸ ì²˜ë¦¬ Job (ì¡°ê±´ë¶€ ì‹¤í–‰ í¬í•¨)
     */
    @Bean
    public Job processOrdersJob(Step processOrdersStep, 
                               Step generateReportsStep,
                               Step sendSummaryNotificationStep,
                               JobExecutionDecider orderProcessingDecider) {
        return new JobBuilder("processOrdersJob", jobRepository)
                .incrementer(new RunIdIncrementer())
                .start(processOrdersStep)
                .next(orderProcessingDecider)                    // ì²˜ë¦¬ ê²°ê³¼ì— ë”°ë¼ ë¶„ê¸°
                .from(orderProcessingDecider).on("CONTINUE")     // ì„±ê³µ ì‹œ ê³„ì†
                    .to(generateReportsStep)
                    .next(sendSummaryNotificationStep)
                .from(orderProcessingDecider).on("STOP")         // ì²˜ë¦¬í•  ë°ì´í„° ì—†ìŒ
                    .end()
                .build();
    }
    
    /**
     * ì£¼ë¬¸ ì²˜ë¦¬ Step
     */
    @Bean
    public Step processOrdersStep(
            @Qualifier("pendingOrderReader") ItemReader<Order> reader,
            ItemProcessor<Order, ProcessedOrderDto> processor,
            ItemWriter<ProcessedOrderDto> writer) {
        
        return new StepBuilder("processOrdersStep", jobRepository)
                .<Order, ProcessedOrderDto>chunk(5, transactionManager)
                .reader(reader)
                .processor(processor)  
                .writer(writer)
                // ê³ ê¸‰ ì—ëŸ¬ ì²˜ë¦¬ ì„¤ì •
                .faultTolerant()
                .skipLimit(10)                                 // ìµœëŒ€ 10ê°œ ìŠ¤í‚µ í—ˆìš©
                .skip(Exception.class)                         // ëª¨ë“  ì˜ˆì™¸ì— ëŒ€í•´ ìŠ¤í‚µ
                .noSkip(OutOfMemoryError.class)               // OOMì€ ìŠ¤í‚µ ì•ˆí•¨
                .retryLimit(3)                                 // ìµœëŒ€ 3ë²ˆ ì¬ì‹œë„
                .retry(org.springframework.dao.TransientDataAccessException.class)
                .listener(orderProcessingStepListener())       // Step ë¦¬ìŠ¤ë„ˆ ë“±ë¡
                .build();
    }
    
    /**
     * ë¦¬í¬íŠ¸ ìƒì„± Step
     */
    @Bean
    public Step generateReportsStep() {
        return new StepBuilder("generateReportsStep", jobRepository)
                .tasklet((contribution, chunkContext) -> {
                    log.info("ğŸ“Š Generating daily reports...");
                    
                    // ì‹¤ì œë¡œëŠ” ë¦¬í¬íŠ¸ ìƒì„± ë¡œì§ êµ¬í˜„
                    Thread.sleep(2000);  // ì²˜ë¦¬ ì‹œê°„ ì‹œë®¬ë ˆì´ì…˜
                    
                    log.info("âœ… Daily reports generated successfully");
                    return RepeatStatus.FINISHED;
                }, transactionManager)
                .build();
    }
    
    /**
     * ìš”ì•½ ì•Œë¦¼ ë°œì†¡ Step
     */
    @Bean
    public Step sendSummaryNotificationStep() {
        return new StepBuilder("sendSummaryNotificationStep", jobRepository)
                .tasklet((contribution, chunkContext) -> {
                    JobExecution jobExecution = contribution.getStepExecution().getJobExecution();
                    
                    // Job ì‹¤í–‰ í†µê³„ ì •ë³´ ìˆ˜ì§‘
                    StepExecution processOrdersStep = jobExecution.getStepExecutions()
                            .stream()
                            .filter(step -> "processOrdersStep".equals(step.getStepName()))
                            .findFirst()
                            .orElse(null);
                    
                    if (processOrdersStep != null) {
                        int processedCount = processOrdersStep.getWriteCount();
                        int skippedCount = processOrdersStep.getSkipCount();
                        
                        String summary = String.format(
                            "ğŸ“ˆ Order Processing Summary:\n" +
                            "âœ… Processed: %d orders\n" +
                            "âš ï¸ Skipped: %d orders\n" +
                            "â±ï¸ Duration: %d ms",
                            processedCount, skippedCount,
                            processOrdersStep.getEndTime().getTime() - processOrdersStep.getStartTime().getTime()
                        );
                        
                        log.info(summary);
                        
                        // ì‹¤ì œë¡œëŠ” ê´€ë¦¬ìì—ê²Œ ì´ë©”ì¼ ë°œì†¡
                        log.info("ğŸ“§ Summary notification sent to administrators");
                    }
                    
                    return RepeatStatus.FINISHED;
                }, transactionManager)
                .build();
    }
    
    /**
     * ì£¼ë¬¸ ì²˜ë¦¬ ê²°ê³¼ì— ë”°ë¥¸ Flow ì œì–´ Decider
     */
    @Bean
    public JobExecutionDecider orderProcessingDecider() {
        return new JobExecutionDecider() {
            @Override
            public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) {
                
                if (stepExecution == null) {
                    return new FlowExecutionStatus("STOP");
                }
                
                int processedCount = stepExecution.getWriteCount();
                ExitStatus exitStatus = stepExecution.getExitStatus();
                
                log.info("ğŸ¤” Decision point - Processed: {}, Exit status: {}", 
                        processedCount, exitStatus.getExitCode());
                
                // ì²˜ë¦¬ëœ ì£¼ë¬¸ì´ ìˆê³  ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œëœ ê²½ìš° ê³„ì† ì§„í–‰
                if (processedCount > 0 && ExitStatus.COMPLETED.equals(exitStatus)) {
                    log.info("â¡ï¸ Continuing to report generation");
                    return new FlowExecutionStatus("CONTINUE");
                } else {
                    log.info("â¹ï¸ Stopping job - No orders processed or step failed");
                    return new FlowExecutionStatus("STOP");
                }
            }
        };
    }
    
    /**
     * ì£¼ë¬¸ ì²˜ë¦¬ Step ë¦¬ìŠ¤ë„ˆ
     */
    @Bean
    public OrderProcessingStepListener orderProcessingStepListener() {
        return new OrderProcessingStepListener();
    }
}
```

### Step ë¦¬ìŠ¤ë„ˆ
```java
package com.example.batchtutorial.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.StepExecutionListener;
import org.springframework.stereotype.Component;

/**
 * ì£¼ë¬¸ ì²˜ë¦¬ Stepì˜ ì‹¤í–‰ ìƒíƒœë¥¼ ëª¨ë‹ˆí„°ë§í•˜ëŠ” ë¦¬ìŠ¤ë„ˆ
 */
@Slf4j
@Component
public class OrderProcessingStepListener implements StepExecutionListener {
    
    @Override
    public void beforeStep(StepExecution stepExecution) {
        log.info("ğŸš€ Starting order processing step: {}", stepExecution.getStepName());
        log.info("ğŸ“‹ Job parameters: {}", stepExecution.getJobParameters());
    }
    
    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        long duration = stepExecution.getEndTime().getTime() - stepExecution.getStartTime().getTime();
        
        log.info("âœ… Order processing step completed: {}", stepExecution.getStepName());
        log.info("ğŸ“Š Processing statistics:");
        log.info("   - Read count: {}", stepExecution.getReadCount());
        log.info("   - Write count: {}", stepExecution.getWriteCount());
        log.info("   - Skip count: {}", stepExecution.getSkipCount());
        log.info("   - Filter count: {}", stepExecution.getFilterCount());
        log.info("   - Duration: {} ms", duration);
        
        // ì²˜ë¦¬ ì„±ëŠ¥ í‰ê°€
        if (duration > 60000) {  // 1ë¶„ ì´ìƒ
            log.warn("âš ï¸ Step execution took longer than expected: {} ms", duration);
        }
        
        if (stepExecution.getSkipCount() > 0) {
            log.warn("âš ï¸ {} orders were skipped during processing", stepExecution.getSkipCount());
        }
        
        return stepExecution.getExitStatus();
    }
}
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ ë°ì´í„° ë° ì‹¤í–‰

### í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„± (data.sql)
```sql
-- src/main/resources/data.sql

-- ê³ ê° ë°ì´í„°
INSERT INTO customers (name, email, phone, grade, total_points, total_purchase_amount, created_at, updated_at) VALUES
('ê¹€ì² ìˆ˜', 'kim@example.com', '010-1234-5678', 'BRONZE', 0, 0, NOW(), NOW()),
('ì´ì˜í¬', 'lee@example.com', '010-2345-6789', 'SILVER', 5000, 150000, NOW(), NOW()),
('ë°•ë¯¼ìˆ˜', 'park@example.com', '010-3456-7890', 'GOLD', 12000, 600000, NOW(), NOW());

-- ìƒí’ˆ ë°ì´í„°
INSERT INTO products (name, price, stock_quantity, category, is_active, created_at, updated_at) VALUES
('ë…¸íŠ¸ë¶', 1200000, 50, 'ì „ìì œí’ˆ', true, NOW(), NOW()),
('ìŠ¤ë§ˆíŠ¸í°', 800000, 100, 'ì „ìì œí’ˆ', true, NOW(), NOW()),
('ì±…ìƒ', 300000, 20, 'ê°€êµ¬', true, NOW(), NOW()),
('ì˜ì', 150000, 30, 'ê°€êµ¬', true, NOW(), NOW());

-- ì£¼ë¬¸ ë°ì´í„°
INSERT INTO orders (customer_id, order_number, status, total_amount, order_date, created_at, updated_at) VALUES
(1, 'ORD-001', 'PENDING', 1200000, '2024-08-25 10:00:00', NOW(), NOW()),
(2, 'ORD-002', 'PENDING', 800000, '2024-08-25 11:00:00', NOW(), NOW()),
(3, 'ORD-003', 'PENDING', 450000, '2024-08-25 12:00:00', NOW(), NOW());

-- ì£¼ë¬¸ ì•„ì´í…œ ë°ì´í„°
INSERT INTO order_items (order_id, product_id, product_name, quantity, unit_price, total_price) VALUES
(1, 1, 'ë…¸íŠ¸ë¶', 1, 1200000, 1200000),
(2, 2, 'ìŠ¤ë§ˆíŠ¸í°', 1, 800000, 800000),
(3, 3, 'ì±…ìƒ', 1, 300000, 300000),
(3, 4, 'ì˜ì', 1, 150000, 150000);
```

ì´ì œ ê³ ê¸‰ ë°ì´í„°ë² ì´ìŠ¤ ì—°ë™ê³¼ ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ í¬í•¨ëœ ì™„ì „í•œ Spring Batch ì‹œìŠ¤í…œì´ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤! ë‹¤ìŒ ë‹¨ê³„ì—ì„œëŠ” ì„±ëŠ¥ ìµœì í™”ì™€ ëª¨ë‹ˆí„°ë§ì— ëŒ€í•´ í•™ìŠµí•˜ê² ìŠµë‹ˆë‹¤.